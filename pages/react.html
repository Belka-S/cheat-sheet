<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>React</title>

  <link rel="stylesheet" href="../css/index.min.css">
</head>

<body>
  <header id="goit" class="header container">
    <nav class="nav">
      <ul class="nav__list">
        <li><a href="../index.html">Main</a></li>
        <li><a href="../pages/html-css.html">HTML-CSS</a></li>
        <li><a href="../pages/js.html">JS</a></li>
        <li><a href="../pages/react.html">React</a></li>
        <li><a href="../pages/node.html">Node</a></li>
        <!-- <li><a href=""></a></li> -->
        <li><a href="../pages/terminal.html">terminal</a></li>
        <li><a href="https://www.edu.goit.global/uk/learn/6420780/2294/2295/textbook" target="_blank"
            rel="noopener noreferrer nofollow">GoIT</a></li>
        <li><a href="https://github.com/Belka-S?tab=repositories" target="_blank"
            rel="noopener noreferrer nofollow">GitHub</a></li>
        <li><a href="https://chat.openai.com/chat" target="_blank" rel="noopener noreferrer nofollow">OpenAI</a></li>
      </ul>
    </nav>
  </header>

  <main class="container">
    <section>
      <div class="goit">
        <h2><a href="https://www.edu.goit.global/learn/6420780/31183/31218/textbook" target="_blank"
            rel="noopener noreferrer nofollow">GoIT React</a></h2>
        <ul class="goit__contents">
          <li><a href="#introduction">Introduction to React <span>(Lesson 1)</span>
              <div>
                <a href="https://www.youtube.com/watch?v=jy7ElyM6m7I" target="_blank">R01
                  <span>components-collections</span></a>
                <a href="https://www.youtube.com/watch?v=YlzdeQvIC6E" target="_blank">N01 <span>components</span></a>
                <a href="https://youtu.be/swMufMMi24U" target="_blank">N01 <span></span></a>
                <a href="https://youtu.be/VYoY0U6YohU" target="_blank">X01 <span></span></a>
              </div>
            </a></li>
          <li><a href="#stylization">Stylization <span>(Lesson 2)</span>
              <div>
                <a href="https://www.youtube.com/watch?v=XRs3v6pNOH8" target="_blank">R02.1
                  <span>components-stylization-modules</span></a>
                <a href="https://www.youtube.com/watch?v=S9-zFqxeEr8" target="_blank">R02.2
                  <span>emotion</span></a>
                <a href="https://www.youtube.com/watch?v=zA0IXdx-yAw" target="_blank">N02
                  <span>styled-components</span></a>
                <a href="https://youtu.be/AwVqHVwuTTg" target="_blank">N02 <span></span></a>
                <a href="https://youtu.be/PmJkyFJ9nhs" target="_blank">X02 <span></span></a>
              </div>
            </a></li>
          <li><a href="#events-state">Events and State <span>(Lesson 3)</span>
              <div>
                <a href="https://www.youtube.com/watch?v=8XLLAQy7Dn0" target="_blank">R03 <span>events-state</span></a>
                <a href="https://www.youtube.com/watch?v=vJ9yjWuPrrM" target="_blank">N03 <span>events-state</span></a>
                <a href="https://youtu.be/6r99-pQzOZU" target="_blank">N03 <span></span></a>
                <a href="https://youtu.be/dDBx1OLZNYs" target="_blank">X03 <span></span></a>
              </div>
            </a></li>
          <li><a href="#forms">Forms <span>(Lesson 4)</span>
              <div>
                <a href="https://www.youtube.com/watch?v=0nwx0xTBhrQ" target="_blank">R04.1 <span>forms</span></a>
                <a href="https://www.youtube.com/watch?v=hZNiA0CE7qw" target="_blank">R04.2 <span>formik-yup</span></a>
                <a href="https://www.youtube.com/watch?v=n9M2rDafvlY" target="_blank">N04 <span>formik-yup</span></a>
                <a href="https://youtu.be/aTGi4zOG2ME" target="_blank">N04 <span></span></a>
                <a href="https://youtu.be/c4V77zAJMGQ" target="_blank">X04 <span></span></a>
              </div>
            </a></li>
          <li><a href="#lifecycle">Lifecycle <span>(Lesson 5)</span>
              <div>
                <a href="https://www.youtube.com/watch?v=rKzrg6N8qco" target="_blank">R05.1 <span>lifecycle</span></a>
                <a href="https://www.youtube.com/watch?v=FbXe8QOW9jI" target="_blank">R05.2
                  <span>player-reader</span></a>
                <a href="https://www.youtube.com/watch?v=eIQi61gLx2g" target="_blank">N05 <span>lifecycle</span></a>
                <a href="https://youtu.be/wJoNzYEuGas" target="_blank">N05 <span></span></a>
                <a href="https://youtu.be/OcTvIgm8h5k" target="_blank">X05 <span></span></a>
              </div>
            </a></li>
          <li><a href="#requests">HTTP-requests <span>(Lesson 6)</span>
              <div>
                <a href="https://www.youtube.com/watch?v=i1czm8PnRvo" target="_blank">R06.1
                  <span>http-requests</span></a>
                <a href="https://www.youtube.com/watch?v=dyOYs35-pKg" target="_blank">R06.2 <span>REST-API</span></a>
                <a href="https://www.youtube.com/watch?v=OG3VSsWn7L4" target="_blank">N06 <span>http-requests</span></a>
                <a href="https://youtu.be/3FUw6vyzT7o" target="_blank">N06 <span></span></a>
                <a href="https://youtu.be/bxCY-U0Umrc" target="_blank">X06 <span></span></a>
              </div>
            </a></li>
          <li><a href="#hooks">React Hooks <span>(Lesson 7)</span>
              <div>
                <a href="https://www.youtube.com/watch?v=6Pt4DY3Tlfs" target="_blank">R07.01 <span>hooks</span></a>
                <a href="https://www.youtube.com/watch?v=R5PR4z65Stc" target="_blank">R07.02 <span>hooks</span></a>
                <a href="https://www.youtube.com/watch?v=tLnyu28yODM" target="_blank">N07 <span>hooks</span></a>
                <a href="https://youtu.be/uCIxCfmhOss" target="_blank">N07 <span></span></a>
                <a href="https://youtu.be/P6rJ2lFvcrc" target="_blank">X07 <span></span></a>
              </div>
            </a></li>
          <li><a href="#context-refs">Context and Refs <span>(Lesson 8)</span>
              <div>
                <a href="https://www.youtube.com/watch?v=Ovbji4uY0yk" target="_blank">R08.01 <span>hooks</span></a>
                <a href="https://www.youtube.com/watch?v=UIk2-oFTCc4" target="_blank">R08.02 <span>load-more</span></a>
                <a href="https://www.youtube.com/watch?v=SM5tmcO1YTs" target="_blank">N08
                  <span>useRef-AbortController-useMemo-useCallback</span></a>
                <a href="https://youtu.be/d_1MkQn2gEc" target="_blank">N08 <span></span></a>
                <a href="https://youtu.be/k6rWrySB9Tg" target="_blank">X08 <span></span></a>
              </div>
            </a></li>
          <li><a href="#routing-one">Routing part 1 <span>(Lesson 9)</span>
              <div>
                <a href="https://youtu.be/xlibkp-dmGs" target="_blank">R09 <span>routing</span></a>
                <a href="https://www.youtube.com/watch?v=8dGFQvv3hog" target="_blank">N09 <span></span></a>
                <a href="https://youtu.be/WhsQzgTZFQM" target="_blank">X09 <span></span></a>
              </div>
            </a></li>
          <li><a href="#routing-two">Routing part 2 <span>(Lesson 10)</span>
              <div>
                <a href="https://youtu.be/RILcHxnva6Q" target="_blank">R10 <span>routing</span></a>
                <a href="https://www.youtube.com/watch?v=7ajSWrCmZEY" target="_blank">N10 <span></span></a>
                <a href="https://youtu.be/RhNRukwQ9t0" target="_blank">X10 <span></span></a>
              </div>
            </a></li>
          <li><a href="#redux">Redux Fundamentals <span>(Lesson 11)</span>
              <div>
                <a href="" target="_blank">R11 <span></span></a>
                <a href="" target="_blank">N11 <span></span></a>
                <a href="https://www.youtube.com/watch?v=nFGTwGg8mc4" target="_blank">N11 <span></span></a>
                <a href="https://youtu.be/JKFc73R-idI" target="_blank">X11 <span></span></a>
              </div>
            </a></li>
          <li><a href="#redux-toolkit">Redux Toolkit <span>(Lesson 12)</span>
              <div>
                <a href="" target="_blank">R12 <span></span></a>
                <a href="" target="_blank">N12 <span></span></a>
                <a href="https://www.youtube.com/watch?v=1OcSD1qmJoY" target="_blank">N12 <span></span></a>
                <a href="https://youtu.be/To6zzghMr_I" target="_blank">X12 <span></span></a>
              </div>
            </a></li>
          <li><a href="#async-redux">Async Redux <span>(Lesson 13)</span>
              <div>
                <a href="" target="_blank">R13 <span></span></a>
                <a href="" target="_blank">N13 <span></span></a>
                <a href="https://www.youtube.com/watch?v=KkrMjqmg0lk" target="_blank">N13 <span></span></a>
                <a href="" target="_blank">X13 <span></span></a>
              </div>
            </a></li>
          <li><a href="#selector">Selector optimization <span>(Lesson 14)</span>
              <div>
                <a href="" target="_blank">R14 <span></span></a>
                <a href="" target="_blank">N14 <span></span></a>
                <a href="https://www.youtube.com/watch?v=Q9eOMFwuxlQ" target="_blank">N14 <span></span></a>
                <a href="" target="_blank">X14 <span></span></a>
              </div>
            </a></li>
          <li><a href="#users">Users <span>(Lesson 15-16)</span>
              <div>
                <a href="" target="_blank">R15-16 <span></span></a>
                <a href="" target="_blank">N15-16 <span></span></a>
                <a href="https://www.youtube.com/watch?v=yc8W6-nZc5M" target="_blank">N15-16 <span></span></a>
                <a href="" target="_blank">X15-16 <span></span></a>
              </div>
            </a></li>
          <li><a href="#portals">Portals <span>(Additionally)</span>
              <div>
                <a href="" target="_blank">RaDD <span></span></a>
                <a href="" target="_blank">NaDD <span></span></a>
                <a href="https://www.youtube.com/watch?v=8TnJ37TSbkI" target="_blank">NaDD <span></span></a>
                <a href="" target="_blank">XaDD <span></span></a>
              </div>
            </a></li>
        </ul>
      </div>
    </section>
    <section class="introduction">
      <a href="#goit">
        <h2 id="introduction">Introduction to React <span>(Lesson 1)</span></h2>
      </a>
      <h3>Web Applications</h3>
      <p>There is always some set of pages, such as a home page, a profile page, a collection page, and a collection
        item details page.The modern approach is a site where a user never navigates to other HTML pages (Single-page
        Application). The interface, instead of requesting HTML documents from the server, is redrawn on the client, on
        the same page, without reloading.</p>
      <h3>React Library</h3>
      <p>React is a library for creating user interface elements, HTML markup can be rendered on the server
        (<a href="https://nextjs.org/" target="_blank" rel="noopener noreferrer">Next.js</a>), write native
        (<a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener noreferrer">React Native</a>)
        or desktop (<a href="Electron" target="_blank" rel="noopener noreferrer">Electron</a>) applications. <b>Browser
          DOM</b> is a tree representation of an HTML document, where each element of the document is represented as a
        DOM node. <b>Virtual DOM</b> is an abstraction, a lightweight copy of a real DOM tree as a JSON object. In
        React, each interface element is a component (custom or built-in) that depends on props or state, and is
        represented by virtual DOM tree nodes. When a component changes, a new virtual DOM tree is created.</p>
      <h3>Tools</h3>
      <p>To create a React application, you need <b>Node.js</b>, <b>Webpack</b>, <b>Babel</b>, <b>ESLint</b>,
        <b>React</b> and <b>DevTools</b>. For small and medium projects, it is recommended to use the utility from the
        authors of <a href="https://react.dev/" target="_blank" rel="noopener noreferrer">React</a> and check
        out the documentation <a href="https://create-react-app.dev/" target="_blank" rel="noopener noreferrer">Create
          React App</a>. In the <a
          href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
          target="_blank" rel="noopener noreferrer">developer tools</a>, there are the component tree, their state and
        props.
      </p>
      <ul>
        <li><b>npx create-react-app</b> <i>project_folder_name</i> - to create an application in the project_folder_name
          folder;</li>
        <li><b>npx create-react-app .</b> - to create an application in the current folder</li>
      </ul>
      <h3>JSX</h3>
      <p>JSX (JavaScript Syntax Extension) - an extension of JavaScript syntax that is convenient to describe the markup
        of what we want to see on the screen. It allows you to use XML-shaped (Extensible Markup Language) syntax
        directly in JavaScript, describes objects - Virtual DOM elements, Babel transforms JSX into function calls.</p>
      <h3>Render Elements to DOM Tree</h3>
      <p>In order to render an element into the DOM tree, the react-dom package has methods
        <b>.createRoot(</b>container<b>)</b> and <b>.render(</b>element<b>)</b> that work together: <br>
        ReactDOM<b>.createRoot(</b>document.getElementById("root")<b>).render(</b>element<b>)</b>
      </p>
      <h3>Common Parent Rule</h3>
      <p>An expression is a single value, the result of some calculations, hence the rule of a common parent. If the
        extra wrapper tag is not needed in the markup, fragments are used. Fragment syntax can be shortened and no
        <i>Fragment</i> imports added. Babel will do all the necessary transformations, replacing empty JSX tags with
        <b>React.Fragment.</b>
      </p>
      <span>import { <b>Fragment</b> } from "react"; <br>
        const post = (
        &#60<b>Fragment</b>>
        &#60h2>Post Header&#60/h2>
        &#60p>Post text&#60/p>
        &#60/<b>Fragment</b>>
        );
      </span>
      <h3>Components</h3>
      <p>Components are the basic building blocks of React applications, with the help of which the interface is divided
        into independent parts. In its simplest form, a component is a JavaScript function with a very simple contract:
        the function takes a property object called <b>props</b> and returns a tree of React elements. The component
        name must start with a capital letter.
      </p>
      <ul>
        <li>Components accept arbitrary <b>properties</b> and return React elements describing what should be rendered
          to the DOM: <br>
          const <b>Product</b> = props => (
          &#60div className = {props.class}>
          &#60h2>{props.name}&#60/h2>
          &#60/div>
          ); <br>
          ReactDOM.createRoot(document.getElementById("root")).render( &#60<b>Product</b> class = "test" name =
          {obj.name}
          />);
        </li>
        <li>In order to specify default property values of the <b>props</b> object, the default value syntax is used
          when destructuring props.</li>
        <li>In the form of <b>children</b> it's easy to pass components, both built-in and custom: <br>
          const Panel = ({ title, <b>children</b> }) => (
          &#60section>
          &#60h2>{title}&#60/h2>
          {<b>children</b>}
          &#60/section>
          );
        </li>
        <li>The <a href="https://www.npmjs.com/package/prop-types" target="_blank"
            rel="noopener noreferrer">prop-types</a> package provides a set of validators to validate received data
          types at runtime, notifying inconsistencies in the console: <br>
          Product.<b>propTypes</b> = {
          imgUrl: PropTypes.string,
          name: PropTypes.string.isRequired,
          price: PropTypes.number.isRequired,
          };
        </li>
      </ul>
      <h3><a href="https://www.robinwieruch.de/conditional-rendering-react/#conditional-rendering-in-react-if"
          target="_blank" rel="noopener noreferrer">Conditional Rendering</a></h3>
      <p>To conditionally render markup, branching and conditional operators are used. Conditions can be checked before
        the markup is returned, or directly in JSX.</p>
      <ul>
        <li><b>if</b> with logical operator <b>&&</b>: <br>
          {unreadMessages.length <b>></b> 0 <b>&&</b> (&#60p>You have {unreadMessages.length} unread messages.&#60/p>
          )}
        </li>
        <li><b>if...else</b> with <b>ternary</b> operator: <br>
          &#60p> {unreadMessages.length <b>></b> 0
          <b>?</b> `You have ${unreadMessages.length} unread messages.`
          <b>:</b> "No unread messages."}&#60/p>
        </li>
        <li><b>switch case</b>: <br>
          {(( ) => { <br>
          <b>switch</b> (status) {
          <b>case</b> 'warning':
          return
          &#60Warning text={text} />;
          <b>case</b> 'error':
          return
          &#60Error text={text} />;
          default:
          return null;} <br>
          })( )}
        </li>
      </ul>
      <h3>Collections</h3>
      <p>In order to render a collection of elements of the same type, the <i>Array.prototype</i><b>.map( )</b> method
        is
        used, the callback function of which, for each element of the collection, returns JSX markup. <b>Key</b> is a
        special string prop that must be set when creating collection elements. Elements within a collection must be
        provided with keys in order to have a stable identity. React uses keys to determine which elements in the
        collection need to be re-created and re-rendered rather than using elements from a previous render. This way we
        avoid recreating all the elements of the collection every time something changes.
      </p>
      <span>{books.map({book} => (
        &#60li <b>key={</b>book.id<b>}</b>>{book.name}&#60/li>
        ))}</span>
    </section>
    <section class="stylization">
      <a href="#goit">
        <h2 id="stylization">Stylization <span>(Lesson 2)</span></h2>
      </a>
      <h3>Inline Styles</h3>
      <p>There are several ways to style components, the simplest yet most limited are inline styles. For this, the
        <b>style</b> attribute is used, which in React takes not a string, but a styles object.
      </p>
      <span>const <b>alertStyles</b> = {
        margin: 8,
        padding: "12px 16px",
        borderRadius: 4,
        backgroundColor: "gray",
        }; <br>
        const App = ( ) => {
        return (
        &#60>
        &#60p <b>style</b>={<b>alertStyles</b>}>Please update your email!&#60/p>
        &#60/>
        );
        };</span>
      <h3>Vanilla CSS</h3>
      <p>The styles of each component are declared in a separate CSS file with the <b>.css</b> extension. The file name
        consists of the component name and extension. For example, for a component <i>Alert</i>, the stylesheet will be
        named <i>Alert.css</i>. Class selector names must be unique throughout the application so that there are no css
        rules conflicts with the same selectors in different components. To calculate the final value of the className
        attribute, we could use an <b>if...else</b> block, a <b>switch</b> statement, a <b>ternary</b> operator, or any
        other JavaScript syntax that would give us the same result. </p>
      <span>src/components/<b>Alert.css</b>: <br>
        <b>.alert {</b>
        margin: 8px;
        padding: 12px 16px;
        border-radius: 4px;
        background-color: gray;
        <b>}</b> <br>
        src/components/<b>Alert.js</b>: <br>
        <b> import "./Alert.css"</b>;
        const Alert = ({ children }) => {
        return &#60p <b>className</b>="<b>alert</b>">{children}&#60/p>;
        };</span> <br>
      <p>
        <b>import</b> classNames from 'classnames' <br>
        className=(<b>classNames(</b>baseName, {activeName: true}<b>)</b>) - to show/hide <b>activeName</b> on
        true/false value.
      </p>


      <h3>Library clsx</h3>
      <p>The <a href="https://www.npmjs.com/package/clsx" target="_blank" rel="noopener noreferrer">clsx library</a> is
        used to solve most problems related to many classes that are specified according to certain conditions. Of
        course JavaScript provides a rich syntax, but in most cases you write unproductive solutions or poorly readable
        code. The library standardizes this process and makes it more convenient through thoughtful syntax.</p>
      <h3>CSS Modules</h3>
      <p>CSS modules are not an official specification, they are not implemented in browsers. This is a process that is
        started at the build stage of a project, as a result of which class names are replaced with unique ones. This
        allows to use the same class name in different CSS files without having to worry about name conflicts. This
        approach was designed to solve the problem of global scope in CSS.</p>
      <ul>
        <li><b>Create React App</b> supports CSS modules
          by default, all you need to do is create style files with a <b>.module.css</b> extension, like
          <i>Alert.module.css.</i> Any valid CSS can be used inside a CSS module. <br>
          <span>
            <b>import</b> css from "./Alert<b>.module.css</b>"; <br>
            const Alert = ({ children }) => {
            return &#60p className={<b>css.alert</b>}>{children}&#60/p>;
            };
          </span>
        </li>
        <li><b>Selector composition</b> is one of the key features of CSS modules, which allows you to create a class
          that inherits the styles of another class without duplicating them. The composes property must precede other
          rules so that styles can be overridden if necessary. <br>
          <span>
            <b>import</b> css from "./Alert<b>.module.css</b>"; <br>
            const Alert = ({ <b>variant</b>, children }) => {
            return &#60p className={css[<b>variant</b>]}>{children}&#60/p>;
            };
          </span>
        </li>
        <li><b>Library clsx</b> is to compose the final value of the className property. <br>
          <b>import</b> clsx from "<b>clsx</b>"; <br>
          <b>import</b> css from "./Alert<b>.module.css</b>"; <br>
          const Alert = ({ variant, outlined, elevated, children }) => {
          return ( <br>
          &#60p className={clsx(css[variant], { [css.isOutlined]: outlined, [css.isElevated]: elevated, })}>
          {children}
          &#60/p>
          );
          };
        </li>
        <li>
          In order to add the ability to use <b>preprocessor SASS</b>, install its compiler in the project
          (<b>npm install sass</b>), but the ability to compose components makes them less useful, as it replaces
          concepts. <br>
          Create <b>.env</b> and put in it <b>SASS_PATH=src</b> to use <b>@import</b> 'styles/index.scss'.
        </li>
      </ul>
      <h3>Librarys @emotion and styled-components</h3>
      <p>
        Install to start <b>@emotion/react</b> <b>@emotion/styled</b> or <b>styled-components</b> . Syntax:
      <ul>
        <li>fileName<b>.styled.js</b> - to make stiles in the same file directory;</li>
        <li>import <b>styled</b> from '@emotion/styled' - to import <i>styled</i> object;</li>
        <li>export const <b>Container</b> = <b>styled.</b>div<b>`</b>\\css-styles;\\
          color: ${props => ${props.color}}
          <b>`</b> - to make style-function, supports nested selectors, <b>&</b>-sign is optional;
        </li>
        <li>import { <b>Container</b> } from './path' <br>
          &#60<b>Container</b> type={type}>\\Inner HTML&#60/<b>Container</b>> - to apply styles;
        </li>
        <li>import { <b>createGlobalStyle</b> } from 'styled-components';<br>
          export const GlobalStyle = createGlobalStyle`\\CSS-styles` <br>
          &#60<b>GlobalStyle</b> /> - to apply global styling;
        </li>
        <li>import { <b>ThemeProvider</b> } from 'styled-components'; <br>
          const <b>theme</b> = {\\Object}; - to make global theme constants in index.js;
        </li>
        <li>npm <b>install</b> modern-normalize and <b>import</b> 'modern-normalize' - to normalize styles.</li>
      </ul>
      </p>
      <h3>Style normalization</h3>
      <p>Element styles may vary between browsers. Built into <b>Create React App</b> is the ability to use
        <a href="https://github.com/csstools/postcss-normalize" target="_blank" rel="noopener noreferrer">
          PostCSS Normalize</a> wich is mix of several popular stylesheets (
        <a href="https://github.com/csstools/normalize.css" target="_blank" rel="noopener noreferrer">
          normalize.css</a> and <a href="https://github.com/csstools/sanitize.css" target="_blank"
          rel="noopener noreferrer">sanitize.css</a>) with normalization best practices. In addition to standardizing
        the appearance of elements, it can be useful to reset or add some of the global element styles.
      </p>
      <p>
        src/<b>index.js</b> <br>
        import "./index.css"; <br>
      </p>
      <span>
        src/<b>index.css</b> <br>
        @import-normalize; <br>
        body {
        font-family: sans-serif;
        line-height: 1.5;
        } <br>
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        p {
        margin: 0;
        }<br>
        ul,
        ol {
        margin: 0;
        padding: 0;
        }<br>
        img {
        display: block;
        max-width: 100%;
        height: auto;
        }
      </span>

    </section>
    <section class="events-state">
      <a href="#goit">
        <h2 id="events-state">Events and State <span>(Lesson 3)</span></h2>
      </a>
      <h3>Class Components</h3>
      <p>To add dynamics, components are created as regular ES6 classes, so all rules apply: constructor, methods,
        context (this). You must declare a mandatory render( ) method, which is called by default and returns JSX
        markup.
      </p>
      <span>
        import <b>React</b> from "react"; <br>

        <b>class</b> MyClassComponent <b>extends</b> React.Component <b>{</b>
        static defaultProps = {};
        static propTypes = {}; <br>
        <b>render</b>( ) {
        return &#60div>Class Component&#60/div>;
        } <b>}</b>
      </span>
      <h3>Events</h3>
      <p>For a native browser event, React creates a <i>SyntheticEvent Object</i> wrapper object with an identical
        interface. Event props are no exception and are named using camelCase. For example <b>onClick</b>,
        <b>onChange</b>, <b>onSubmit</b>, <b>onMouseEnter</b>. The event prop is passed a reference to the callback
        function that will be called when the event occurs. Event handlers receive an instance of <i>SyntheticEvent
          Object</i>.
      </p>
      <span><b>handleOnClick</b> = <b>(</b>event<b>) =></b> {console.log(event); console.log(this);}</span> <br>
      <span>&#60button <b>onClick</b>=<b>{</b>this.handleOnClick<b>}</b>>Click Me&#60/button></span>
      <h3>Internal state of the component</h3>
      <p>The <b>state</b> object is a class property that should not be changed directly by the developer. The data in
        <b>state</b> controls what is displayed in the interface. The data stored in the state should be information
        that will be updated by the component methods. Every time the state of the component (or props) changes, the
        <b>render( )</b> method is called.
      </p>
      <ul>
        <li><b>Initial state from props.</b> Sometimes the initial state depends on the passed props, for example, the
          initial value of our counter. In this case, you must explicitly declare the props parameter in the constructor
          and pass it to the super(props) call. Then this.props will be available in the constructor. <br>
          <b>constructor( ) {</b>
          super( );
          this.<b>state</b> = {
          value: 0,
          };
          <b>}</b>
          <p>Since Babel is used under the hood, we can skip the tedious constructor declaration and specify the state
            as a public property of the class, the transpiler will do the rest for us. <br>
            <b>static</b> defaultProps = { initialValue: 0, };<br>
            <b>state</b> = <b>{</b> value: this.props.initialValue, <b>}</b>; <br>
            &#60Counter <b>initialValue</b>=<b>{</b>10<b>}</b> />
          </p>
        </li>
        <li>
          <p>
            <b>Changing the state of a component.</b> The built-in <b>setState(</b>updater, callback<b>)</b> method is
            used to update the state. This approach is used when the new state is not calculated based on the previous
            one. That is, when something new is written to the state, overwriting the existing one. <br>
            this<b>.setState(</b>{value: newValue}<b>)</b>
          </p>
        </li>
        <li>
          <p>
            <b>How the state is updated.</b> When calling <b>setState( )</b>, you do not need to pass all the properties
            stored in the state. It is enough to specify only that part (slice) of the state that we want to change in
            this operation. React then takes the current state and the object that was passed to <i>setState( )</i>,
            concatenating them as follows. <br>
            const <b>nextState</b> = <b>{</b> ...currentState, ...updateSlice <b>}</b>;
          </p>
        </li>
        <li>
          <p>
            <b>State update asynchrony.</b> The <b>setState( )</b> method registers an asynchronous state update
            operation that is queued for updates. React does not change the state for every call to <b>setState( )</b>,
            but
            can combine multiple calls into one update to improve performance. Because of this, accessing
            <b>this.state</b>, in synchronous code, after calling this method will return the value before the update.
            Therefore, you cannot rely on the current state when calculating the next one, which depends on the previous
            one at the time of the update. This may lead to errors. <br>
            this.setState(<b>prevState</b> => <b>(</b>{ value: <b>prevState</b>.value + 1 }; <b>)</b> );
          </p>
        </li>
        <li>
          <p>
            <b>setState with function.</b> This approach is used when a new value is calculated based on the previous
            state. The <b>setState( )</b> method, as the first argument, can take not an object, but a function that
            should
            return the object with which we want to update the state. The current state and props, at the time of
            asynchronous execution of the function passed to setState( ), will be passed to it as arguments <b>state</b>
            and <b>props</b>. <br>
            <b>setState(</b>(state, props) => {
            return {};
            }, callback<b>)</b>;
          </p>
        </li>
        <li>
          <p>
            <b>Lifting state.</b> Since React uses a one-way data flow from top to bottom, in order to change the state
            of the parent on an event in the child, the following callback pattern is used. <br>
            const Button = ({ <b>changeMessage</b>, label }) => (
            &#60button type="button" onClick={<b>changeMessage</b>}>
            {label}
            &#60/button>
            );<br>
            &#60Button label="Change message" <b>changeMessage</b>={this.updateMessage} />

          <ul>
            <li>The parent has a state and a method that changes it.</li>
            <li>The child, in the form of a prop, is forwarded the method of the parent that changes the state of the
              parent.</li>
            <li>In the child there is a call of the method transferred to it.</li>
            <li>When this method is called, the state of the parent is changed.</li>
            <li>There is a re-render of a subtree of components of the parent.</li>
          </ul>
          </p>
        </li>
        <li>
          <p>
            <b>Internal data types of the class component.</b>
          <ul>
            <li><i>static data</i> - static properties and methods that need to be accessed without an instance.</li>
            <li><i>this.state.data</i> - dynamic data changed by component methods, state.</li>
            <li><i>this.data</i> - data that will be different for each instance.</li>
            <li><i>const DATA</i> - constants, data that does not change and is the same for all instances.</li>
          </ul>
          </p>
        </li>
      </ul>
    </section>
    <section class="forms">
      <a href="#goit">
        <h2 id="forms">Forms <span>(Lesson 4)</span></h2>
      </a>
      <h3>Uncontrolled elements</h3>
      <p>The main purpose of any form is to get user data. To do this, during the submission, you can get the values of
        the fields from its <b>elements</b> property or using <b>FormData</b>. This technique is appropriate to use when
        the form field data is needed only during its submission.</p>
      <h3>Controlled elements</h3>
      <p>If the values of the form elements need to be retrieved at the time of the field change and do something
        dynamically, they must be controlled. That is, the values of all fields must be in <b>state</b>. The field in
        <b>state</b> defines the <b>value</b> of the value attribute of the field. The <b>onChange</b> event is passed a
        method that changes the field in the state. <br>
        class <b>App</b> extends Component <b>{</b>
        <b>state</b> = <b>{</b>
        inputValue: "",
        <b>}</b>;<br>
        <b>handleChange</b> = evt => <b>{</b>
        this.<b>setState</b>({ inputValue: evt.target.value });
        <b>}</b>; <br>
        <b>render( ) {</b>
        const { inputValue } = this.state;
        return (
        &#60input type="text" <b>value</b>={inputValue} <b>onChange</b>={this.handleChange} />
        );
        <b>}</b>
        <b>}</b>
      </p>
      <h3>Complex shapes</h3>
      <p>A very useful pattern for the callback function passed to onChange. <br>
        handleChange = evt => {
        const { <b>name</b>, <b>value</b> } = evt.target;
        this.setState({ [<b>name</b>]: <b>value</b> });
        };</p>
      <h3>Generate the Id of the form elements</h3>
      <p><b>Accessibility</b> (a11y) is a very important topic in today's web. The <b>for</b> HTML attribute of the
        <b>label</b> tag helps assistive technology and other assistive technologies. In React, it is represented by the
        <b>htmlFor</b> jsx attribute. To generate unique identifiers for form elements, the following approach is used:
        for each element instance, when it is initialized, a set of unique identifiers is created (<a
          href="https://www.npmjs.com/package/shortid" target="_blank" rel="noopener noreferrer">shortid</a>) and stored
        on the instance.
      </p>
      <h3>Checkboxes</h3>
      <p>Working with checkboxes is simple and straightforward. A checkbox can have only 2 states: true or false. <br>
        <b>state</b> = <b>{</b>
        ...INITIAL_STATE,
        <b>}</b>; <br>

        <b>handleChange</b> = evt => <b>{</b>
        const { name, value, type, checked } = evt.target;
        this.<b>setState(</b>{ [name]: type === "checkbox" ? checked : value }<b>)</b>;
        <b>}</b>;<br>
      </p>
      <ul>
        <li>The name of the attribute to which the current value from <b>state</b> is passed. For checkboxes, this is
          <b>checked</b>, and we pass a boolean there.
        </li>
        <li>When handling the <b>onChange</b> event, to get the value, in the event object, we access the
          <b>event.target.checked</b> property.
        </li>
        <li>If the checkbox must store a <b>value</b>, it can also be hung on the value attribute and read from the
          event object.</li>
      </ul>
      <p>
        this.setState(<b>prevState</b> => <b>(</b>{todos: prevState.todos.map(<b>todo</b> => <br>
        todo.id === todoId <b>?</b> {...todo, completed: !todo.completed} <b>:</b> todo, ), }<b>)</b>)
      </p>
      <h3>Radio buttons</h3>
      <p>Unlike the usual grouping by the value of the <b>name</b> attribute, in React a radio button is just an
        interface element that knows if it is selected and c an ask the form to change the selection. Usually radio
        buttons have both a <b>checked</b> attribute and a <b>value</b> attribute. <br>
        &#60input type="radio" <b>checked</b>=<b>{</b>this.state.gender==="male"<b>}</b> <b>value</b>="male"
        onChage={this.handleGenderChange} />
      </p>
      <h3>Select</h3>
      <p>There is a select, there are options, the select has <b>value</b> and <b>onChange</b>.
      </p>
    </section>
    <section class="lifecycle">
      <a href="#goit">
        <h2 id="lifecycle">Lifecycle <span>(Lesson 5)</h2>
      </a>
      <h3>Lifecycle</h3>
      <p>There are several lifecycle stages - mounting, updation and unmounting. During each of them, methods inherited
        from <i>React.Component</i> are called on the component class. There are seven lifecycle methods in total, not
        counting render and constructor. In practice, in most everyday tasks, three are used: <b>componentDidMount</b>,
        <b>componentDidUpdate</b> Ð¸ <b>componentWillUnmount</b>.
      </p>
      <h3>Mounting stage</h3>
      <p>The following methods are called in this order when the component is instantiated and added to the DOM.</p>
      <ul>
        <li><b>constructor( ) {}</b> - called when the component is instantiated, before the component is placed in the
          DOM, initializes the initial state of the component, binds context in methods;
        </li>
        <li>static <i>getDerivedStateFromProps(</i>nextProps, prevState<i>) {}</i> - method is rarely used in practice,
          called before <i>render( )</i>, on mount, and before all subsequent calls to render, i.e. after updating
          <i>state</i> or <i>props</i>, an be used to set <i>state</i> depending on <i>props</i> each time they change,
          no access to <i>this</i>;
        </li>
        <li><b>render( ) {}</b> - allows to declaratively describe the interface, returns the result of JSX expressions,
          Virtual DOM subtree, can't call <i>setState( )</i>;</li>
        <li><b>componentDidMount( ) {}</b> - called immediately after the component is mounted in the DOM, making HTTP
          requests, hanging custom event listeners and performing operations with the DOM tree, calling
          <i>setState( )</i> in this method will cause a re-render.
        </li>
      </ul>
      <h3>Update stage</h3>
      <p>An update can be triggered by a change in the <i>state</i> of the component itself or the <i>props</i> passed
        to it. On update, the component needs to be re-rendered, which leads to the following methods being called.</p>
      <ul>
        <li><b>shouldComponentUpdate(</b>nextProps, nextState<b>) {}</b> - called before re-rendering an already mounted
          component, allows to compare current and previous state and props by returning true or false telling React if
          the component needs to be updated, if it returns false then <i>render( )</i> and <i>componentDidUpdate( )</i>
          will not happen</li>
        <li><b>getSnapshotBeforeUpdate(</b>prevProps, prevState<b>) {}</b> - method is rarely used in practice, called
          before any changes are ready to be added to the DOM, can be used to get pre-update DOM values, such as the
          current scroll position or the size of the element before the update, what this method returns will be passed
          as the third <i>snapshot</i> parameter to <i>componentDidUpdate( )</i>;</i></li>
        <li><b>componentDidUpdate(</b>prevProps, prevState, snapshot<b>) {}</b> - called immediately after updating the
          component in the DOM, not called when the component is initially rendered, it is possible to call
          <i>setState( )</i>, making sure to wrap it in a condition to check.
        </li>
      </ul>
      <h3>Unmounting stage</h3>
      <p>At some point, the component will be removed from the DOM. This calls the <b>componentWillUnmount( ) {}</b>
        method. It is called before the element is unmounted and removed from the DOM, great for cleaning up after
        yourself: listeners, timers, HTTP requests. Otherwise there will be memory leaks.</p>
      <h3>Handling render errors</h3>
      <p>The <b>componentDidCatch(</b>error, info<b>) {}</b> method fires on an error in a child component and allows
        parent components to catch errors in children by displaying a fallback interface. As a result, when an error
        occurs, the interface does not crash. It catches errors only in children, but not in the parent itself,
        <b>error</b> - result of <i>toString( )</i> error object, <b>info</b> - an object describing the stack trace.
      </p>
    </section>

    <section class="requests">
      <a href="#goit">
        <h2 id="requests">HTTP-requests <span>(Lesson 6)</h2>
      </a>
      <h3>HTTP Requests</h3>
      <p>The <b>componentDidMount</b> and <b>componentDidUpdate</b> lifecycle methods are ideal for HTTP requests.
        When <b>componentDidMount( )</b> is called, the component has already been rendered to the DOM and is ready for
        a subsequent state update. When <b>componentDidUpdate( )</b> is called, the props or the state of the component
        have changed, and it may be necessary to make a new request, comparing them first, so as not to loop the
        component's render. Anything can be used for an HTTP request: <b>XMLHTTPRequest</b>, <b>fetch</b>, <b>axios</b>,
        <b>superagent</b>, etc.
      </p>
      <span>
        async <b>componentDidMount( ) {</b>
        const response = await axios.get("/search?query=react");<br>
        <b>this.setState(</b>{ articles: response.data.hits }<b>)</b>;
        <b>}</b>
      </span>
      <h3>Loading indicator / Error handling</h3>
      <p>
        While we are waiting for a response to the HTTP request, we show the download walker. As soon as the answer
        comes, hide the indicator. To do this, at the start of the request, set <b>isLoading</b> to <i>true</i>, and on
        a successful response or error, set it to <i>false</i>.
      </p>
      <p>To make clear if something went wrong add the error storage property to the state. When using promises, the
        catch block is used to handle errors, if it is executed, then an error has occurred. We move the loading
        indicator setting to the finally block so as not to duplicate the code that will be executed anyway. </p>
      <span>
        async <b>componentDidMount( ) {</b>
        this.<b>setState(</b>{ isLoading: true }<b>)</b>;<br>
        <b>try {</b>
        const response = await axios.get("/search?query=react");
        this.<b>setState(</b>{ articles: response.data.hits }<b>)</b>;<b>}</b><br>
        <b>catch (</b>error<b>) {</b>
        this.<b>setState(</b>{ error }<b>)</b>;<b>}</b><br>
        <b>finally {</b>
        this.<b>setState(</b>{ isLoading: false }<b>)</b>;<b>}}</b>
      </span>
      <h3>Separation of responsibility</h3>
      <p>It is not a good practice to store HTTP request related code directly in the component, <b>services</b> folder
        will store a file with functions for HTTP requests.</p>
      <span>
        export const fetchData = <b>async</b> searchQuery => {<br>
        const response = <b>axios.get(</b>`/search?query=${searchQuery}`<b>)</b>;<br>
        <b>return</b> response.data.hits; };
      </span>
    </section>
    <section class="hooks">
      <a href="#goit">
        <h2 id="hooks">React Hooks <span>(Lesson 7)</h2>
      </a>
      <h3>Difference with classes</h3>
      <p>In a class component, we can create only one common state, and in a functional one, as many as we like, and
        they will be independent of each other. Any hooks can only be called at the top level of a function component.
        That is, outside of loops, conditions, nested functions, etc.</p>
      <h3>Hook useState</h3>
      <p> The <b>useState</b> hook returns an array of two elements: the first is the current state value, the second is
        a function to change it, which can be used anywhere, for example, in an event handler. Calling the
        <b>useState</b> hook creates a state and a method that will change its value. As a parameter, the hook takes the
        initial state. Any type of data can be stored in the state.
      </p>
      <ul>
        <li>import { <b>useState</b> } from "react";</li>
        <li>const [<b>value</b>, <b>setValue</b>] = <b>useState(</b>( ) <b>=></b> localStorage.getItem(LS_KEY) ??
          null<b>)</b> - <b>lazy state initialization</b> (synchronous code only);
        </li>
        <li>&#60button type="button" onClick={( )=> <b>setValue(</b><i>prevState</i> <b>=></b> <i>prevState</i> +
          1<b>)</b>}</li>
      </ul>
      <h3>Hooks useEffect and useLayoutEffect</h3>
      <p>Lifecycle methods are used to perform some operations at different stages of the component's life. Using the
        <b>useEffect</b> hook in function components, you can perform all these "effects" by simulating the work of
        three life cycle methods - <i>componentDidMount</i>, <i>componentDidUpdate</i>, <i>componentWillUnmount</i>,
        combining them into one API. The <b>useLayoutEffect</b> perform the layout measurements before the browser
        repaints the screen.
      </p>
      <ul>
        <li>import { <b>useEffect</b> } from "react";</li>
        <li><b>useEffect(</b>callback, deps<b>)</b>:
          <ul>
            <li><i>callback</i> - a function with the logic of the effect is executed (requests to the server, setting
              event handlers for a document, etc.);</li>
            <li><i>dependencies</i> - an array of variables, if any of them changes, the effect will be launched and the
              callback will be executed.</li>
          </ul>
        </li>
        <li>useEffect(( ) => { //do smth. }, <b>[ ]</b>) - similar to <b>componentDidMount</b>, the <i>useEffect</i>
          hook is fired not only when the elements of the dependency array change, but also immediately after the
          component is mounted. If we specify an empty array as the second argument, the callback will run at the
          component's mounting stage, and never again;</li>
        <li>useEffect(( ) => { console.log(value); }, <b>[</b>value<b>]</b>) - similar to <b>componentDidUpdate</b>,
          which is
          launched only when certain values change, it is also launched at the mounting stage;
        </li>
        <li>useEffect(( ) => { //do smth. <b>return ( )</b> => <b>{</b> //cleanup }; <b>}</b>, <b>[ ]</b>) - similar to
          <b>componentWillUnmount</b>, to remove event handlers, stop timers, and cancel HTTP requests we return the
          cleanup function from useEffect with the necessary code.
        </li>
      </ul>
      <h3>Custom Hooks</h3>
      <p>Creating your own hooks is the process of extracting component logic into reusable functions. This will make
        the project code cleaner and easier to maintain. It's better to use the built-in React hooks or ready-made hooks
        from libraries like <a href="https://github.com/streamich/react-use" target="_blank"
          rel="noopener noreferrer">react-use</a>. A hook is simply a function whose name necessarily begins with
        the prefix <b>use</b>. A custom hook can take any arguments and return anything, there are no rules, it depends
        on the implementation.
      </p>
      <span>
        // src/hooks/<b>useToggle</b>.js <br />
        export const useToggle = (initialState = false) => { <br />
        const [isOpen, setIsOpen] = useState(initialState); <br />
        const open = ( ) => setIsOpen(true); <br />
        const close = ( ) => setIsOpen(false); <br />
        const toggle = ( ) => setIsOpen(isOpen => !isOpen); <br />
        return { isOpen, open, close, toggle }; };
      </span>
    </section>
    <section class="context-refs">
      <a href="#goit">
        <h2 id="context-refs">Context and Refs <span>(Lesson 8)</span></h2>
      </a>
      <h3>Context</h3>
      <p>Data is passed from top to bottom via props, but this can be inconvenient for certain global data that is
        required by many components at different levels in the application. Context provides a way to pass data deep
        down the component tree without having to explicitly pass props to intermediate components manually at each
        level.</p>
      <ul>
        <li>Function <b>createContext( )</b> reates a context object containing a pair of components:
          <i>&#60Context.Provider></i> and <i>&#60Context.Consumer></i>, <i>defaultValue</i> argument is used by the
          consumer if it does not have a corresponding provider above it in the tree:
          <p>
            import { <b>createContext</b> } from "react"; <br>
            const MyContext = <b>createContext(</b>defaultValue<b>)</b>;
          </p>
        </li>
        <li>The <b>&#60Provider></b> component allows consumers to subscribe to context changes regardless of nesting
          depth, used to create and pass a context, accepts prop value - the value of the context, which will be passed
          to the child-consumers of this context:
          <p>
            &#60MyContext.<b>Provider</b> value={/* context value */}> <br>
            &#60App /> <br>
            &#60/MyContext.<b>Provider</b>
        </li>
        </p>
      </ul>
      <h3>Hook useContext</h3>
      <p>The <b>useContext( )</b> hook allows you to access the current context value. Gets the current context from the
        closest matching <i>&#60Provider></i> above in the tree, expects a single argument - a link to the created
        context, returns the context value of the nearest provider for this context higher in the tree:
      <p>
        import { createContext, <b>useContext</b> } from "react"; <br>
        const contextValue = <b>useContext(</b>MyContext<b>)</b>; <br>
      </p>
      export const <b>useMyContext</b> = ( ) => useContext(MyContext); - import and use this hook in components.</p>
      <h3>Hook useRef</h3>
      <p>Refs allow direct access to DOM nodes or React elements from a component's template. They are used when it is
        necessary to access the imperative methods and properties of an element (element focus on event, text selection,
        control of media content playback).
      </p>
      <ul>
        <li>Refs are created by the <b>useRef( )</b> hook and attached to React elements using the <b>ref</b> attribute,
          which will store a reference to the DOM element:
          <p>
            import { <b>useRef</b> } from "react"; <br>
            const App = ( ) => { const btnRef = <b>useRef( )</b>; <br>
            return &#60button <b>ref</b>=<b>{</b>btnRef<b>}</b>>Button&#60/button>; };
          </p>
        </li>
        <li>React sets the <i>current property</i> to a reference to the DOM element when the component <i>is
            mounted</i> and <i>null when unmounted</i>, so the value of the ref is only available <b>after mounting</b>.
        </li>
        <li><b>Refs</b> are <b>not state</b>, meaning they are not reactive, so changing the value of a ref does not
          affect component updates or cause a re-render. Refs can also be used as storage for arbitrary values that do
          not change between renders of a component and do not affect it.</li>
        <li>When using <i>refs</i> on a component, the <i>ref</i> prop is not automatically passed. The
          <b>forwardRef</b> function automatically passes the props received by the parent component to its
          children. This approach allows you to get a link in the parent component to a DOM element inside another
          component. For example, you create a gallery, so you can get links to DOM elements from outside and work with
          their properties, for example, use the <i>Element.getBoundingClientRect( )</i> method and the like. <br>
          <p>
            import { <b>forwardRef</b>, useRef, useEffect } from "react"; <br>
            const CustomButton = <b>forwardRef(</b>(props, ref) => ( &#60button ref={ref}>{props.children}&#60/button>
            )<b>)</b>;
          </p>
        </li>
      </ul>
      <h3>Hook useMemo</h3>
      <p>The <b>useMemo( )</b> hook uses the concept of memoization, that is, it returns a stored (cached) result of the
        calculation. This can improve application performance if used to prevent expensive calculations on every render.
        The hook takes two arguments - an anonymous function that should return a <b>value</b> (compute), which will be
        memoized, and an array of <b>dependencies</b> (deps):
      </p>
      <span>
        import { <b>useMemo</b> } from 'react'; <br>
        const memoizedValue = <b>useMemo(</b> ( ) => computeExpensiveValue(a, b), [a, b] <b>)</b>;
      </span>
      <p>The method <b>memo( )</b> uses the concept of memoization for components, wich is similar to
        <b>PureComponent</b>:
      </p>
      <span>
        import { <b>memo</b> } from 'react'; <br>
        export default <b>memo(</b>Navigation<b>)</b>; <br>
        export <b>memo(</b>function MyFunction ( ) { ... }<b>)</b>;
      </span>

      <h3>Hook useReducer</h3>
      <p>Components with many state updates spread across many event handlers can get overwhelming. To consolidate all
        the state update logic outside your component in a single function, called a <b>reducer</b>.</p>
      <ul>
        <li><b>reducer</b> function specifies how the state gets updated. It must be pure, should take the state
          and action as arguments, and should return the next state. State and action can be of any types.</li>
        <li><b>initialArg</b> is the value from which the initial state is calculated, can be a value of any type.</li>
        <li><b>init</b> function should return the initial state, if itâs not specified, the initial state is set
          to initialArg, otherwise, the initial state is set to the result of calling <b>init(</b>initialArg<b>)</b>.
        </li>
        <li><b>action</b> can be a value of any type, it is usually an object with a type property identifying it and,
          optionally, other properties with additional information.
        </li>
        <li><b>dispatch</b> function updats the state to a different value and trigger a re-render, it takes the
          <b>action</b> as the only argument.
        </li>
      </ul>
      <span>
        import { <b>useReducer</b> } from 'react'; <br>
        const action = {type: 'resolved', load: {status: RESOLVED}}; <br>
        function <b>reducer(</b>state, action<b>)</b> {
        switch (action.type){ <br>
        case 'resolved': return { ...state, ...action }; <br>
        case 'error': return { ...state, ...action }; <br>
        } } <br>
        function <b>init( )</b> { return { status: IDLE } //to set lazy inizialisation of <i>initialState</i> } <br>
        function MyComponent( ) { const [state, dispatch] = <b>useReducer(</b>reducer, { status: IDLE }, init<b>)</b>;
        //... <br>
        dispatch({ status: RESOLVED })
        }
      </span>
    </section>
    <section class="routing-one">
      <a href="#goit">
        <h2 id="routing-one">Routing part 1 <span>(Lesson 9)</span></h2>
      </a>
      <h3>Routing in React</h3>
      <p>Navigation history describes how we navigate the routes (links) of the application in current browser tab and
        how those transitions are stored and handled.There is a history stack. Using HTML5 History API properties and
        methods we can go back and forth through the user's history and manipulate its contents. Any URL
        <b>https://mysite.com/books/e3q76gm9lzk?category=adventure&status=unread#comments</b> can consist of:
      </p>
      <ul>
        <li><b>https://</b> - protocol;</li>
        <li><b>mysite.com/</b> - host;</li>
        <li><b>books/e3q76gm9lzk</b> - the path where we are in the application;</li>
        <li><b>e3q76gm9lzk</b> - url parameter, can be dynamic or static;</li>
        <li><b>?</b> - the symbol of the beginning of the query string;</li>
        <li><b>?category=adventure&status=unread</b> - query string;</li>
        <li><b>category=adventure</b> - parameter=value pair;</li>
        <li><b>&</b> - symbol "AND", separates parameters of the query string;</li>
        <li><b>#comments</b> - anchor (hash), defines position on the page.
        </li>
      </ul>
      <h3>React Router</h3>
      <p>React doesn't have a built-in routing module, so the <b><a href="https://reactrouter.com/en/main"
            target="_blank" rel="noopener noreferrer">React Router</a></b>, a routing library for React. It
        provides a set of components and hooks for creating routing, managing history user navigation and displaying
        different components depending on current URL value:</p>
      <ul>
        <li>&#60<b>BrowserRouter</b>> &#60App /> &#60/<b>BrowserRouter</b>> component creates a router and a history
          object navigation to synchronize the interface with the URL, using React context passes information about the
          current state of the navigation history to all descendants.</li>
        <li>&#60<b>Route</b> path="/about" element={&#60<b>About</b> />} /> component allows you to associate a specific
          URL to some component.</li>
        <li>&#60<b>Routes</b>> //... &#60/<b>Routes</b>> - a group of routes must be wrapped by the &#60Routes>
          component, even if there is only one route.</li>
        <li>&#60Route path="*" element={&#60<b>NotFound</b> />} /> - navigation error page.</li>
        <li>
          &#60<b>nav</b>> &#60<b>NavLink</b> to="/">Home&#60/<b>NavLink</b>> &#60<b>Link</b> to="/about">About&#60/Link>
          &#60/<b>nav</b>> - to create links <i>&#60Link></i> and <i>&#60NavLink></i> components are used, the
          <i>&#60NavLink></i> component differs only in that it can have additional styles if the current URL matches
          the value of props <b>to</b>, by default the <b>.active</b> class is added to the active link element.
        </li>
        <li>
          &#60Route path="<b>/products/:productId</b>" element={&#60ProductDetails />} /> - to declare one route with a
          dynamic parameter a colon (<b> : </b>) is used before the parameter name, the value of a URL parameter must be
          unique within the collection, so the most commonly used are object identifiers that the database sets (numbers
          or strings).
        </li>
        <li>import { <b>useParams</b> } from "react-router-dom"; const <b>{</b> genreId, authorName <b>}</b> =
          <b>useParams( )</b>; - hook returns an object containing all dynamic parameters of the current URL
          <b>/books/:genreId/:authorName</b>.
        </li>
        <li>
          The syntax of the declaration nested routes allow to describe the logic of "subpages"
          <b>/about/mission</b> and <b>/about/team</b>, relative paths are written without the leading character
          (<b> / </b>). If the current URL in the browser address bar matches the value of the <b>props path</b> nested
          route, &#60<b>Outlet</b>> will render its component, otherwise it render null.
          <ul>
            <li>
              &#60<b>Route</b> path="<b>/about</b>" element={&#60About />}> <br>
              &#60Route path="<b>mission</b>" element={&#60Mission />} /> <br>
              &#60Route path="<b>team</b>" element={&#60Team />} /> <br>
              &#60/<b>Route</b>>
            </li>
            <li>
              import { Link, <b>Outlet</b> } from "react-router-dom"; <br>
              export const About = ( ) => { return ( &#60div> <br>
              &#60Link to="<b>mission</b>">Read about our mission&#60/Link> <br>
              &#60Link to="<b>team</b>">Get to know the team&#60/Link> <br>
              &#60<b>Outlet</b> />
              &#60/div> ); };
            </li>
          </ul>
        </li>
      </ul>
      <h3>Index routes</h3>
      <p>In order to render a component &#60Home> to the same route on which its parent is rendered, you need to make an
        <b>index</b> route:
      </p>
      &#60Routes> <br>
      &#60<b>Route</b> path="/" element={&#60<b>SharedLayout</b> />}> <br>
      &#60Route <b>index</b> element={&#60<b>Home /</b>>} /> <br>
      &#60Route path="about" element={&#60About />}> <br>
      &#60Route path="mission" element={&#60Mission />} /> <br>
      &#60/<b>Route</b>> <br>
      &#60/Routes> <br>
    </section>
    <section class="routing-two">
      <a href="#goit">
        <h2 id="routing-two">Routing part 2 <span>(Lesson 10)</span></h2>
      </a>
      <h3>Imperative navigation</h3>
      <p>React Router allows you to navigate not only when you click on Link, but also by a specific user action, event,
        or effect. For example, when button, after a form is submitted, by the result of an HTTP request, and so on.
        The <b>replace</b> property, by default <b>false</b>, controls how a new record will be added to the history
        stack.</p>
      <ul>
        <li>import { <b>useNavigate</b> } from "react-router-dom"; <br>
          const <b>navigate</b> = useNavigate( ); <b>navigate(</b>"/path", { replace: true }<b>)</b> - imperative way;
        </li>
        <li>import { <b>Navigate</b> } from "react-router-dom"; <br>
          &#60<b>Navigate</b> to="/path" replace /> - declarative way performs navigation at the time of rendering.
        </li>
      </ul>
      <h3>Query string</h3>
      <p>The query string is added to the main URL, begins with ( <b>?</b> ) and contains one or more parameters in
        key-value format, separated by ( <b>&</b> ).</p>
      <ul>
        <li>const [searchParams, setSearchParams] = <b>useSearchParams( )</b>; - hook, which is a wrapper on top of the
          built-in browser class URLSearchParams. To get the values of the parameters there is a method
          URLSearchParams<b>.get(</b>key<b>)</b></li>
        <li>const [<b>searchParams</b>] = useSearchParams( ); <br>
          const <b>params</b> = useMemo( ( ) => Object.<b>fromEntries(</b>[...searchParams]<b>)</b>, [searchParams] );
          <br>
          const { name, maxPrice, inStock } = <b>params</b>; - a way to convert an instance of the class
          <i>URLSearchParams</i> into a normal object with properties.
        </li>
        <li>onChange={e => <b>setSearchParams(</b>{ name: e.target.value }<b>)</b>} - to change parameters pass an
          object of new parameters, that will completely replace the current query string. If the query string changes,
          the useSearchParams hook will return the new parameters and the component is updated.
        </li>
      </ul>
      <h3>Location object</h3>
      <p>Each entry in the navigation history stack is described by a <b>location</b> object with a standard set of
        properties that store complete information about URL. When a user clicks on links and navigates through the
        application, the current location changes and a new history record is added.</p>
      <ul>
        <li><b>pathname</b> - the string containing part of the URL from the initial ( <b>/</b> ) and up to the symbol (
          <b>?</b> ).
        </li>
        <li><b>search</b> - contains the whole query string. </li>
        <li>
          <b>hash</b> - a string containing part of the URL from the end of the query string and the symbol ( <b>#</b>
          ), followed by the URL fragment identifier.
        </li>
        <li>
          <b>state</b> - an arbitrary value that contains additional information, related to the location, but is not
          shown in the URL. It is set by developer. Used for transferring data between routes.
        </li>
        <li>
          <b>key</b> - a unique identifier string associated with this location. The service property, which value is
          set automatically for each new record in the navigation history.
        </li>
      </ul>
      <p>The <b>state</b> property of a location object allows to transfer arbitrary data when navigating from one route
        to another. To do this we use the props state component <b>Link</b> and pass an object with the property from -
        where the user: </p>
      <span>&#60Link to="/products/h-1" <b>state={</b>{ from: "/dashboard?name=hoodie" }<b>}</b>>product
        h-1&#60/Link></span>
      <p>Hook <b>useLocation</b> returns a location object representing the current URL every time we take a new route
        or update part of the current URL. The value of the props <b>state</b> will be available on the route
        <b>location</b> object where was navigated to. Use the hook <b>useLocation</b> hook to get the location object
        and refer to its state property:
      </p>
      <span>const location = <b>useLocation( )</b>; <br>
        &#60Link to="/product/h-1" state={{ from: <b>location</b> }}>product h-1&#60/Link> <br>
        const backPath = useRef(<b>location.state?.from</b> ?? '/home');<br>
        &#60Link to={<b>backPath</b>.current}>Back to products&#60/Link>
      </span>
      <h3>Code splitting</h3>
      <p>Split the project into smaller files and download them only when needed. This is the concept of code splitting.
        Going to a new page - the necessary code for displaying its components is loaded. This approach is called
        <b>route-centric</b> code partitioning. You can optimize the loading of individual, very large page components
        that are not needed until a certain user action. This approach is called <b>component-centric</b> code
        partitioning.
      </p>
      <ul>
        <li><b>import(</b>"path/to/MyComponent"<b>).then(</b>module => console.log(module)<b>)</b> - ES2020
          specification has added the ability to dynamically import a module, it uses <b>import( )</b> function, which
          returns a promise whose value is the module file.</li>
        <li>
          React provides an API to specify which code should be allocated to a separate file, load and render only when
          necessary. The React<b>.lazy( )</b> function is responsible for loading the component asynchronously, and
          <b>Suspends</b> its display until the loading is complete (use <b>export default</b>):
          <p>
            import { <b>lazy</b>, <b>Suspense</b> } from "react"; <br>
            const MyComponent = <b>lazy(</b>( ) => <b>import(</b>"path/to/MyComponent"<b>)</b><b>)</b>; <b>export
              default</b> MyComponent; <br>
            const App = ( ) => ( <br>
            &#60<b>Suspense</b> fallback={&#60div>Loading...&#60/div>}> <br>
            &#60Routes>
            &#60Route path="/some-path" element={&#60MyComponent />} />
            &#60/Routes> <br>
            &#60/<b>Suspense</b>>
            );
          </p>
        </li>
        <li>
          <p>When using the <b>shared layout</b> technique, put Suspense directly inside the SharedLayout component:</p>
          &#60<b>Suspense</b> fallback={&#60div>Loading...&#60/div>}> <br>
          &#60Outlet /> <br>
          &#60/<b>Suspense</b>>
        </li>
      </ul>
    </section>
    <section class="redux">
      <a href="#goit">
        <h2 id="redux">Redux Fundamentals <span>(Lesson 11)</h2>
      </a>
    </section>
    <section class="redux-toolkit">
      <a href="#goit">
        <h2 id="redux-toolkit">Redux Toolkit <span>(Lesson 12)</h2>
      </a>
    </section>
    <section class="async-redux">
      <a href="#goit">
        <h2 id="async-redux">Async Redux <span>(Lesson 13)</h2>
      </a>
    </section>
    <section class="selector">
      <a href="#goit">
        <h2 id="selector">Selector optimization <span>(Lesson 14)</span></h2>
      </a>
    </section>
    <section class="users">
      <a href="#goit">
        <h2 id="users">Users <span>(Lesson 15-16)</span></h2>
      </a>
    </section>
    <section class="portals">
      <a href="#goit">
        <h2 id="portals">Portals <span>(Additionally)</h2>
      </a>
    </section>

  </main>

  <footer></footer>
</body>

</html>