<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Node.js</title>

  <link rel="stylesheet" href="../css/index.min.css">
</head>

<body>
  <header id="goit" class="header container">
    <nav class="nav">
      <ul class="nav__list">
        <li><a href="../index.html">Main</a></li>
        <li><a href="../pages/html-css.html">HTML-CSS</a></li>
        <li><a href="../pages/js.html">JS</a></li>
        <li><a href="../pages/ts.html">TS</a></li>
        <li><a href="../pages/react.html">React</a></li>
        <li><a href="../pages/react-native.html">React Native</a></li>
        <li><a href="../pages/next.html">Next.js</a></li>
        <li><a href="../pages/node.html">Node.js</a></li>
        <!-- <li><a href=""></a></li> -->
        <li><a href="../pages/terminal.html">terminal</a></li>
        <li><a href="" target="_blank" rel="noopener noreferrer nofollow">GoIT</a></li>
        <li><a href="https://github.com/Belka-S?tab=repositories" target="_blank"
            rel="noopener noreferrer nofollow">GitHub</a></li>
        <li><a href="https://dashboard.render.com/" target="_blank">Render</a></li>
        <li><a href="https://chat.openai.com/chat" target="_blank" rel="noopener noreferrer nofollow">OpenAI</a></li>
      </ul>
    </nav>
  </header>

  <main class="container">
    <section>
      <div class="goit">
        <h2><a href="https://www.edu.goit.global/learn/6420780/2439558/2439561/textbook" target="_blank"
            rel="noopener noreferrer nofollow">GoIT Node.js</a> / <a
            href="https://invented-nickel-d17.notion.site/Node-js-43d2808cd69a404387093449a51d206a" target="_blank"
            rel="noopener noreferrer nofollow">ALT Node.js</a></h2>
        <ul class="goit__contents">
          <li><a href="#basics">The Basics <span>(Lesson 1)</span>
              <div>
                <a href="https://youtu.be/_AsCNHqJVlQ" target="_blank">L01 <span>node-basics</span></a>
                <a href="https://youtu.be/ULja_vtUbGg" target="_blank">M01 <span></span></a>
                <a href="https://youtu.be/SFRtSpCZrsY" target="_blank">N06 <span></span></a>
              </div>
            </a></li>
          <li><a href="#apps">Creating Console Applications <span>(Lesson 2)</span></a>
            <div>
              <a href="https://youtu.be/y5g5K4wAda4" target="_blank">L02 <span>console-app</span></a>
              <a href="https://youtu.be/8gMSXOoykVs" target="_blank">M02 <span></span></a>
              <a href="https://youtu.be/4DQtvF3Vt6Y" target="_blank">N02 <span></span></a>
            </div>
          </li>
          <li><a href="#express">The Framework Express <span>(Lesson 3)</span></a>
            <div>
              <a href="https://youtu.be/2ayBNKGC8hs" target="_blank">L03 <span>express</span></a>
              <a href="https://youtu.be/q8B3wdyUbcU" target="_blank">M03 <span></span></a>
              <a href="https://youtu.be/dI4TLiKvayM" target="_blank">N03 <span></span></a>
              <a href="https://youtu.be/hwc8q1D3C5Y" target="_blank">blended <span></span></a>
            </div>
          </li>
          <li><a href="#restapi">REST API <span>(Lesson 4)</span></a>
            <div>
              <a href="https://youtu.be/mh5kKeEojjA" target="_blank">L04 <span>rest-api</span></a>
              <a href="https://youtu.be/rHvd6ZxZH6I" target="_blank">M04 <span></span></a>
              <a href="https://youtu.be/mEhiVODJukg" target="_blank">N04 <span></span></a>
            </div>
          </li>
          <li><a href="#mongo">The MongoDB Database <span>(Lesson 5)</span></a>
            <div>
              <a href="https://youtu.be/GxAWZIVmWR8" target="_blank">L05 <span>mongo-db</span></a>
              <a href="https://youtu.be/gQpWd0AdSNk" target="_blank">M05 <span></span></a>
              <a href="https://youtu.be/Ytq9Q7DSAaE" target="_blank">N05 <span></span></a>
            </div>
          </li>
          <li><a href="#mongoose">ODM Mongoose <span>(Lesson 6)</span></a>
            <div>
              <a href="https://youtu.be/ptECPvMUfkk" target="_blank">L06 <span>mongoose</span></a>
              <a href="https://youtu.be/wAA02CBZ7wg" target="_blank">M06 <span></span></a>
              <a href="https://youtu.be/mYxAfuBJTjM" target="_blank">N06 <span></span></a>
            </div>
          </li>
          <li><a href="#auth">Authentication and authorization <span>(Lesson 7-8)</span></a>
            <div>
              <a href="https://youtu.be/EDRgbWW-a8U" target="_blank">L07.1 <span>auth</span></a>
              <a href="https://youtu.be/gS0cjVI72Ok" target="_blank">L07.1 <span>auth</span></a>
              <a href="https://youtu.be/4F5Qf5sBQbM" target="_blank">L08 <span>access-refresh</span></a>
              <a href="https://youtu.be/CBN8_aKnzSU" target="_blank">M07 <span></span></a>
              <a href="https://youtu.be/vO7q4boT-Gw" target="_blank">M08 <span></span></a>
              <a href="https://youtu.be/oo4RKkY1KTk" target="_blank">N07.1 <span></span></a>
              <a href="https://youtu.be/pxqd-X3yxyE" target="_blank">N07.2 <span></span></a>
              <a href="https://youtu.be/ff2nn5sZKxk" target="_blank">N08 <span></span></a>
              <a href="https://youtu.be/oQaoymCOW8o" target="_blank">swagger-google <span></span></a>
            </div>
          </li>
          <li><a href="#files">Work with files <span>(Lesson 9)</span></a>
            <div>
              <a href="https://youtu.be/EAdvI-FWhY0" target="_blank">L09 <span>files</span></a>
              <a href="https://youtu.be/-wBe9YSWeGw" target="_blank">N09 <span>cloudinary</span></a>
              <a href="https://youtu.be/8jgNO3WBe0E" target="_blank">M09 <span></span></a>
              <a href="https://youtu.be/4olABZwhb68" target="_blank">N09 <span></span></a>
            </div>
          </li>
          <li><a href="#testing">Testing of Applications <span>(Lesson 10)</span></a>
            <div>
              <a href="https://youtu.be/AqyO6IuT1x8" target="_blank">L10 <span>testing</span></a>
              <a href="https://youtu.be/_HZBWy3UFew" target="_blank">M10 <span></span></a>
              <a href="https://youtu.be/vvkl2Z-L4ss" target="_blank">N10 <span></span></a>
            </div>
          </li>
          <li><a href="#email-docker">Work with email and Docker <span>(Lesson 11)</span></a>
            <div>
              <a href="https://youtu.be/SCemq9kxBGc" target="_blank">L11 <span>email</span></a>
              <a href="https://youtu.be/n9uCgUzfeRQ?list=PLqKQF2ojwm3l6OE4-tjLBhUNtJXLebHXP" target="_blank">X11.1
                <span>docker</span></a>
              <a href="https://www.youtube.com/watch?v=O8N1lvkIjig" target="_blank">X11.2
                <span></span></a>
              <a href="https://youtu.be/20_j03Yhh_A" target="_blank">M11 <span></span></a>
              <a href="https://youtu.be/GiAlVWuSSXE" target="_blank">N11 <span></span></a>
            </div>
          </li>
          <li><a href="#websockets">Websockets <span>(Lesson 12)</span></a>
            <div>
              <a href="https://youtu.be/c01Hhg-xEB8" target="_blank">L12 <span>websockets</span></a>
              <a href="https://youtu.be/KPow3gyBpHc" target="_blank">M12 <span></span></a>
              <a href="https://youtu.be/vXq9gz1Szls" target="_blank">N12 <span></span></a>
              <a href="https://youtu.be/o75CeRMl6jU" target="_blank">QA <span></span></a>
            </div>
          </li>
          <li><a href="#extra">Extra Materials<span>(Additional)</span></a>
            <div>
              <a href="https://youtu.be/ivDjWYcKDZI" target="_blank">EM <span>MERN</span></a>
              <a href="" target="_blank">EM <span></span></a>
              <a href="" target="_blank">EM <span></span></a>
              <a href="" target="_blank">EM <span></span></a>
            </div>
          </li>
        </ul>


      </div>
    </section>
    <section class="basics">
      <a href="#goit">
        <h2 id="basics">The Basics <span>(Lesson 1)</span></h2>
      </a>
      <h3>Global variables</h3>
      <ul>
        <li><b>Global</b> object is analogous to the window object from the browser;</li>
        <li>global<b>.foo</b> = 3; - to make a variable global in Node.js, you must declare it as a property of the
          <b>global</b> object;
        </li>
        <li><b>__filename</b> – a file name of an executable script;</li>
        <li><b>__dirname</b> – an absolute path to the executable script;</li>
        <li><b>Buffer</b> class is used when the object is used for operations with binary data;</li>
        <li><b>Process</b> class is used when process object, most of the data is located here;</li>
        <li>process<b>.argv</b> property contains an array of command line arguments;</li>
        <li>process<b>.cwd( )</b> returns the current working directory;</li>
        <li>process<b>.chdir( )</b> changes to another directory;</li>
        <li>process<b>.exit( )</b> exits the process with the code specified as an argument: 0, which is a success code;
          any number is an error code;</li>
        <li>process<b>.nextTick(</b>fn<b>)</b> is an important method that will schedule the execution of the specified
          function in such a way that the specified function will be executed after the end of the current phase (the
          currently executing code), but before the start of the next phase of the event loop.</li>
      </ul>
      <h3>Modules</h3>
      <p>To connect third-party modules to your project in Node.js, there is a convenient <b>NPM module management
          system</b>. In essence, this is a public repository of additional software modules created using Node.js.</p>
      <ul>
        <li><b>npm install</b> module_name [switches] - to install module;</li>
        <li><b>-S</b> or <b>--save</b> - the module is installed as a main dependency (module is necessary for the
          normal functioning of the program);</li>
        <li><b>-D</b> or <b>--save-dev</b> - means that the module will be installed as an additional dependency</li>
      </ul>
      <p>Modules fall into three categories:</p>
      <ul>
        <li><b>Core</b> modules, such as <i>fs</i> and <i>os</i>, are provided by the Node.</li>
        <li><b>File</b> modules are when you create a file with an exported function that assigns something (function,
          object, etc.) to the module.exports property, and then that file is used in other files in your program.</li>
        <li><b>npm</b> modules are regular file modules that reside in a special folder called node_modules. When you
          use the require function, Node determines the type of the module from the passed string.</li>
      </ul>
      <h3>CommonJS modules</h3>
      <p>Structurally, a CommonJS module is a ready-to-use piece of JavaScript code that exports special objects
        available for use in any code that needs it as a dependency. The two main kinds of CommonJS modules are the
        <b>exports object</b>, which contains what a given module wants to make available to other parts of the system,
        and the <b>require function</b>, which is used by some modules to import the exports object from others.
      </p>
      <ul>
        <li>module<b>.exports</b> – an object responsible for what exactly the module will export;</li>
        <li><b>require</b> method used to include modules is not global and will be local to each module.</li>

      </ul>
      <h3>ECMAScript modules</h3>
      <p>Starting with version 6.x, Node.js also supports connecting modules according to the ECMAScript standard. But
        fully importing modules has only worked since version 14.x. The first way is to give the files a <b>.mjs</b>
        extension so that we can use ECMAScript modules. The second wayis to set<b> "type": "module"</b>, in the
        <b>package.json</b> file.
      </p>
      <h3>Working with Files</h3>
      <p>The FileSystem module is responsible for working with files in Node.js. Module initialization is as follows:
      </p>
      <ul>
        <li>const <b>fs</b> = require(<b>'fs'</b>)<b>.promises</b>;</li>
        <li>const <b>fs</b> = require(<b>'fs/promises'</b>);</li>
      </ul>
      <p>The most used functions for basic file operations are as follows:</p>
      <ul>
        <li>fs<b>.readFile(</b>filename, [options]<b>)</b> - read file;</li>
        <li>fs<b>.writeFile(</b>filename, data, [options]<b>)</b> - write file;</li>
        <li>fs<b>.appendFile(</b>filename, data, [options]<b>)</b>- append to file;</li>
        <li>fs<b>.rename(</b>oldPath, newPath<b>)</b> - rename file;</li>
        <li>fs<b>.unlink(</b>path, callback<b>)</b> - delete file.</li>
      </ul>
      <p>When dealing with files, we never forget to handle errors. The data parameter in the readFile function contains
        the already mentioned object of the <b>Buffer</b> type, containing the sequence of bytes read, i.e. raw data.
        The easiest way to work with data as a string is to convert data using the <b>toString( )</b> method:</p>
      <span>
        fs<b>.readFile(</b>'readme.txt'<b>)</b><b>.then(</b>data => console.log(data<b>.toString(
          )</b>)<b>)</b><b>.catch(</b>error => console.log(error.message)<b>)</b>;
      </span>
    </section>

    <section class="apps">
      <a href="#goit">
        <h2 id="apps">Creating Console Applications <span>(Lesson 2)</span></h2>
      </a>
      <h3>CLI applications</h3>
      <p>The traditional way to manage a console application (CLI applications) is to pass parameters from the console
        line when it is launched. The parameters passed when starting the script are available in the process.args
        array. To process all kinds of combinations of parameters and their formats <a
          href="https://github.com/tj/commander.js#common-option-types-boolean-and-value"><b>program</b></a> or
        <b>yargs</b> modules are usually used:
      </p>
      <ul>
        <li>
          const { <b>program</b> } = require(<b>'commander'</b>); <br>
          program<b>.option(</b>'--action &#60type>'<b>).option(</b>'--id &#60type>'<b>).option(</b>'--name
          &#60type>'<b>)</b> <br>
          program<b>.parse(</b>process.argv<b>)</b>; <br>
          const optionsObgect = program<b>.opts( )</b>; <br>
          <p>
            Options are defined with the <b>.option( )</b> method, also serving as documentation for the options. Each
            option can have a short flag (single character) and a long name, separated by a comma or space or vertical
            bar ('|'). The first argument to <b>.parse(</b>[//array of strings], { <b>from: 'user'</b> }<b>)</b> is the
            array to parse, f the arguments follow different conventions than node you can pass a <b>from</b> option in
            the second parameter. The parsed options can be accessed by calling <b>.opts( )</b> on a Command object, and
            are passed to the action handler. The two most used option types are a boolean option, and an option which
            takes its value from the following argument (declared with angle brackets like <b>--expect
              &#60</b>value<b>></b>). To specify an option which may be used as a boolean option but may optionally take
            an option-argument (declared with square brackets like <b>--optional [</b>value<b>]</b>). You may specify a
            required option using <b>.requiredOption( ).</b> </p>
        </li>
        <li>
          const <b>yargs</b> = require(<b>'yargs'</b>); <br>
          const { <b>hideBin</b> } = require(<b>'yargs/helpers'</b>); <br>
          const arr = <b>hideBin(</b>process.argv<b>)</b>; <br>
          const { <b>argv</b>: optionsObgect } = <b>yargs(</b>arr<b>)</b>;
        </li>
      </ul>
      <p>To use interactive question-and-answer console input, the standard Node.js <b>readline</b> module is used:</p>
      <ul>
        <li>
          const <b>readline</b> = require(<b>'readline'</b>); <br>
          const <b>rl</b> = readline<b>.createInterface(</b>{
          <b>input:</b> process.stdin, <b>output:</b> process.stdout, }<b>)</b>;
        </li>
        <li>rl<b>.on('line', cmd</b> => { console.log(`You just typed: ${<b>cmd</b>}`<b>)</b>;
          }) - each input line is processed through the line event;</li>
        <li>rl<b>.question(</b>'Who are you?', <b>answer</b> => { console.log(`Nice to meet you ${<b>answer</b>}`);
          }<b>)</b> - to ask the user a question and get an answer;</li>
        <li>rl<b>.pause( )</b> - to block the input;</li>
        <li>rl<b>.close( )</b> - to close the readline interface.</li>
      </ul>
    </section>

    <section class="express">
      <a href="#goit">
        <h2 id="express">The Framework Express <span>(Lesson 3)</span></h2>
      </a>
      <h3>Introduction to Express</h3>
      <p><a href="https://expressjs.com/" target="_blank"><b>Express</b></a> is a minimalistic and flexible web
        framework for Node.js applications that provides a rich set of features for mobile and web applications. It has
        many HTTP utility methods and middleware at its disposal to create a robust API or website.</p>

      <span>const <b>express</b> = require(<b>'express'</b>); <br>
        const <b>app</b> = <b>express( )</b>; <br>
        app<b>.listen(</b>3001, ( ) => console.log('Server is running!')<b>)</b>;</span>
      <p>To process requests(routes) Express has a number of built-in functions. The route definition, according to the
        documentation, has the following structure: app.<b>METHOD</b>(<b>PATH</b>, <b>HANDLER</b>). </p>
      <ul>
        <li><b>app</b> - an express application instance;</li>
        <li><b>METHOD</b> — an HTTP request method (GET, POST, PUT, PATCH, DELETE);</li>
        <li><b>PATH</b> — a path to the server, in our case it is the site root '/';</li>
        <li><b>HANDLER</b> - a function to be executed when the route is matched.</li>
      </ul>
      <p>The <i>HANDLER</i> function takes two parameters, a <b>req</b> (request) and a <b>res</b> (response) object.
        Route definitions can contain regular expressions or special wildcards such as <b>?</b> (the previous character
        may occur 1 time or be absent), <b>+</b> (the previous character can occur 1 or more times), <b>*</b> (any
        number of characters can appear in place of this character) and <b>( )</b>.

      </p>
      <span>app<b>.get(</b>'/', (<b>req</b>, <b>res</b>) => { <br>
        console.log(req<b>.url</b>, req<b>.method</b>); <br>
        res<b>.send(</b>'&#60h2>Home Page&#60/h2>'<b>)</b>;
        }<b>)</b>;</span>
      <h3>Middleware</h3>
      <p><b>Middleware</b> are functions that have access to the <b>request</b> object, the <b>response</b> object, and
        the <b>next</b> middleware function in the application's request-response cycle. The middleware functions
        execute some code, make changes to the objects of <b>req</b> and <b>resp</b>, may complete the
        request-response cycle and abort the processing of the request, call the next intermediate processing function
        from the stack by executing the <b>next( )</b> function.</p>
      <ul>
        <li>app<b>.use(</b>(<b>req</b>, <b>res</b>, <b>next</b>) => { const <b>{</b> method, url <b>}</b> = <b>req</b>;
          <br>
          const date = moment( ).format('DD-MM-YYYY_hh:mm:ss'); <br>
          fs.appendFile('./data/server.log', `${method} ${url} ${date}\n`); <br>
          <b>next( )</b>;
          }<b>)</b>;
        </li>
        <li>app<b>.use(</b>(<b>res</b>, <b>req</b>) => {
          res<b>.status(</b>404)<b>.json(</b>{ error: 'Not found' }<b>)</b>;
          }<b>)</b>;</li>
        <li>const cors = require('cors'); <br>
          app<b>.use(</b>cors( )<b>)</b>; - <i>to allows CORS requests</i>;
        </li>
        <li>const contactsRouter = require('./routes/api/contacts'); <br>
          app<b>.use(</b>'/api/contacts', contactsRouter<b>)</b>;
        </li>
        <li>app<b>.use(</b>express.json( )<b>)</b>; - <i>to transform JSON body</i>;</li>
        <li>app<b>.use(</b>(<b>err</b>, <b>req</b>, <b>res</b>, <b>next</b>) => { <br>
          const { status = 500, code, message = 'Server error!' } = <b>err</b>; <br>
          res.status(status).json({ message: err.message });
          }<b>)</b></li>
      </ul>
      <p>To validate sent data <b>validation</b> can be added in middleware function using <a
          href="https://github.com/hapijs/joi" target="_blank" rel="noopener noreferrer"><b>Joi</b></a> validator.</p>
      <span>const <b>Joi</b> = require(<b>'joi'</b>); <br>
        const schema = <b>Joi</b>.object( { <br>
        name: <b>Joi</b>.string( ).required( ), <br>
        email: <b>Joi</b>.string( ).email( ).required( ), }); <br>
        const { <b>error</b> } = schema.<b>validate(</b>req.body<b>)</b>;
      </span>
      <h3>Passing data to a server</h3>
      <ul>
        <li>
          <p><b>Passing a parameter to the URL</b> <br>
            app.get('/contact/:<b>id</b>', (<b>req</b>, res) => {
            const { <b>id</b> } = <b>req.params</b>; });
          </p>
        </li>
        <li>
          <p><b>Using GET request parameters</b> <br>
            http://localhost:3000/contacts?skip=0&limit=10, the result of such a request is in the <b>req.query</b>
            object;
          </p>
        </li>
        <li>
          <p><b>Submit via forms</b> <br>
            app<b>.use(</b>express<b>.urlencoded(</b>{ extended: false }<b>))</b> - to create a form data parser; <br>
            app.post('/login', (<b>req</b>, res, next) => {
            const { email, password } = <b>req.body</b>;
            });
          </p>
        </li>
        <li>
          <p><b>JSON Pass</b> <br>
            app<b>.use(</b>express<b>.json( ))</b> - to connect the JSON parser in the application;<br>
            app.post('/login', (<b>req</b>, res, next) => {
            const { email, password } = <b>req.body</b>;
            });
          </p>
        </li>
      </ul>
      <h3>Application Routing</h3>
      <p>With the <b>express.Router</b> class, you can create modular, mountable route handlers. The Router instance is
        a complex system of middleware and routing. Express supports a large number of <b>routing methods</b>
        corresponding to HTTP methods (<b>get</b>, <b>post</b>, <b>put</b>, <b>delete</b>, <b>patch</b>).</p>
      <span>
        const <b>express</b> = require(<b>'express'</b>); <br>
        const <b>router</b> = express<b>.Router( )</b>; <br>
        const contacts = require('../../data/contacts.json'); <br>
        <b>router</b>.get('/', (req, res) => {
        res.json(contacts); });
      </span>
      <p>The methods on the <b>response</b> object (res) can send a response to the client and complete the
        request-response cycle:</p>
      <ul>
        <li>res<b>.download( )</b> - file upload prompt;</li>
        <li>res<b>.end( )</b> - completing the response process;</li>
        <li>res<b>.json( )</b> - sending a JSON response;</li>
        <li>res<b>.jsonp( )</b> - sending a JSON response with JSONP support;</li>
        <li>res<b>.redirect( )</b> - response redirect;</li>
        <li>res<b>.render( )</b> - view template output;</li>
        <li>res<b>.send( )</b> - ending different types of response;</li>
        <li>res<b>.sendFile( )</b> - sending a file as an octet stream.</li>
      </ul>
      <p>The app<b>.route( )</b> method allows you to create chained route handlers for a particular route path.</p>
    </section>
    <section class="restapi">
      <a href="#goit">
        <h2 id="restapi">REST API <span>(Lesson 4)</span></h2>
      </a>
      <h3>MVC application</h3>
      <p>The Express framework introduces its application <a href="https://expressjs.com/en/starter/generator.html"
          target="_blank" rel="noopener noreferrer">generator</a>. The generator focuses on Model-View-Controller
        application architecture.</p>
      <span>npx express-generator --view=ejs <i>projectName</i> - to install new rpoject;</span>
      <ul>
        <li>
          <p><b>Routes connection:</b> <br>
            const indexRouter = require('./routes/index'); <br>
            const usersRouter = require('./routes/users'); <br>
            app.use('/', indexRouter); <br>
            app.use('/users', usersRouter);
          </p>
        </li>
        <li>
          <p><b>Templates connection:</b> <br>
            app.set('views', path.join(__dirname, 'views')); <br>
            app.set('view engine', 'ejs');
          </p>
        </li>
        <li>
          <p><b>Middleware connection:</b> <br>
            app.use(logger('dev')); <br>
            app.use(express.json( )); <br>
            app.use(express.urlencoded({ extended: false })); <br>
            app.use(cookieParser( ));
          </p>
        </li>
        <li>
          <p><b>Processing of static resources:</b> <br>
            app.use(express.static(path.join(__dirname, 'public')))
          </p>
        </li>
        <li>
          <p><b>Error handling:</b> <br>
            app.use((req, res, next) => { next(createError(404)); }); <i>or</i><br>
            app.use((req, res) => { res.status(404).json({ message: 'Not found' });}); <br>
            app.use((err, req, res, next) => { <br>
            const { status = 500, code, message = 'Server error!' } = err; <br>
            res.status(status).json({ message: err.message });
            });

          </p>
        </li>
      </ul>
      <h3>Environment Variables</h3>
      <p><b>Environment variables</b> areused to access secret data, such as secret words for cookie or jwt, url
        database connection, and so on. They ares are local variables that are available to our application. These
        variables are created using the <b>dotenv</b> module. This module loads environment variables from a <b>.env</b>
        file. After we connect the module in our application and it adds environment variables to the <b>process.env</b>
        object, from there, without showing the values of these variables, we can use them in the application. We must
        add the <b>.env</b> file to the <b>.gitignore</b> file
      </p>
      <ul>
        <li>npm install <b>dotenv</b> - to install module;</li>
        <li>require(<b>'dotenv'</b>)<b></b>.config( ) - add in <b>app.js</b> to configure;</li>
        <li><b>.env</b> file in the root directory of application and add variables: <br>
          <b>SECRET_KEY</b>=123456 <br>
          <b>NODE_ENV</b>=development
        </li>
        <li>any variables added to the <b>.env</b> file will now be available in the application's <b>app.js</b> file:
          <br>
          const {<b>SECRET_KEY</b>, <b>NODE_ENV</b>} = process<b>.env</b>
        </li>
      </ul>
      <h3>Logging</h3>
      <p>To log requests to the server the <a href="https://www.npmjs.com/package/morgan" target="_blank"
          rel="noopener noreferrer"><b>morgan</b></a> module is used, it is called as a middleware function. There are
        five predefined formats (<i>combined</i>, <i>common</i>, <i>dev</i>, <i>short</i>, <i>tiny</i>) and custom log
        formats.
      </p>
      <span>
        const <i>morgan</i> = require(<b>'morgan'</b>); <br>
        app<b>.use(</b>logger(<b>'dev'</b>)<b>)</b>
      </span>
      <h3>RESTful Architectural Constraints</h3>
      <p><b>REST</b> (REpresentational State Transfer). It is a set of design principles for increasing the scalability
        and flexibility of network communications. A RESTful system must be flexible for different use cases, scale to
        support a large number of users and components, and adapt over time. It is any network that satisfies the next
        constraints.</p>
      <ul>
        <li><b>Client-Server.</b> The network must be composed of clients and servers. A RESTful system must work in a
          client-server model.</li>
        <li><b>Stateless.</b> Servers and clients don't need to keep track of each other's state.</li>
        <li><b>Single Interface.</b> When a system has identifiers for each resource, manipulates them by sending
          representations from the client to the server, and has messages that are informative and consist of
          hypermedia, it is said to have a single interface. </li>
        <li><b>Caching.</b> Refers to the restriction that server responses must be marked as cacheable or
          non-cacheable.</li>
        <li><b>Multi-layer</b> (<b>Multi-Level</b>) <b>System</b>. There can be more components than just servers
          and clients. This means that there can be more than one level in the system. However, each component is
          limited to only see and interact with the next layer.</li>
        <li><b>Code on Request</b> (optional). Refers to the server's ability to send executable code to the client.
        </li>
      </ul>
      <h3>Basic HTTP Methods</h3>
      <p>Idempotent is a property of an object or operation, when the operation is applied to the object again, to give
        the same result as the first time. The main or most commonly used HTTP methods are GET / POST / PUT / DELETE.
      </p>
      <ul>
        <li><b>GET</b> method used to get (or read) a representation of a resource. If the address is successful, the
          <b>GET</b> method returns an <b>XML</b> or <b>JSON</b> representation of the resource, combined with an HTTP
          <b>200</b> (OK) status code. On failure, <b>404</b> (NOT FOUND) or <b>400</b> (BAD REQUEST) is returned.
        </li>
        <li><b>POST</b> method is used to create new resources or nested resources. When a new resource is created, the
          <b>POST</b> request sends a view, and the service takes responsibility for assigning an <b>ID</b> to the new
          resource. If the resource is successfully created, the HTTP code <b>201</b> Create is returned, and a Location
          header can be set with the address of the created resource.
        </li>
        <li><b>PUT</b> (<b>PATCH</b>) method is used to update a resource. The request body when sending a <b>PUT</b>
          request to an existing URL resource must contain the updated data of the original resource (in full, or only
          the updated part - <b>PATCH</b>). A successful update returns <b>200</b> (or <b>204</b> if no content was
          passed in the response body).</li>
        <li><b>DELETE</b> method is used to delete a resource identified by a specific URL (ID). Upon successful
          deletion of the resource, a <b>200</b> (OK) HTTP code is returned, along with a response body containing the
          details of the deleted resource. It is also possible to use the HTTP code <b>204</b> (NO CONTENT) without a
          response body.</li>
      </ul>
      <h3>HTTP response codes</h3>
      <p>Any response from the server must indicate an HTTP status code. It indicates whether a particular HTTP request
        was successfully completed. <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Status" target="_blank"
          rel="noopener noreferrer"><b>HTTP codes</b></a> are divided into five groups:</p>
      <ol>
        <li><b>Information 100 - 199</b> <br>
          100: Continue</li>
        <li><b>Successful 200 - 299</b> <br>
          200: OK <br>
          201: Created <br>
          202: Accepted <br>
          204: No Content
        </li>
        <li><b>Redirects 300 - 399</b> <br>
          301: Moved Permanently <br>
          307: Temporary Redirect
        </li>
        <li><b>Client errors 400 - 499</b> <br>
          400: Bad Request <br>
          401: Unauthorized <br>
          403: Forbidden <br>
          404: Not Found <br>
          409: Conflict
        </li>
        <li><b>Server errors 500 - 599</b> <br>
          500: Internal Server Error <br>
          501: Not Implemented <br>
          502: Bad Gateway <br>
          503: Service Unavailable <br>
          504: Gateway Timeout
        </li>
      </ol>
      <span>
        <b>helpers</b>/HttpError.js <br>
        const errorMessage = {
        400: 'Bad Request',
        401: 'Unauthorized',
        403: 'Forbidden',
        404: 'Not Found',
        409: 'Conflict', <br>
        500: 'Internal Server Error',
        501: 'Not Implemented',
        502: 'Bad Gateway',
        503: 'Service Unavailable',
        504: 'Gateway Timeout',
        }; <br>

        const <b>HttpError</b> = <b>(</b>status, message = errorMessage[status]<b>) => {</b> <br>
        const <b>error</b> = new Error(message);
        error<b>.status</b> = status;
        <b>return</b> error; <b>}</b>;
      </span>
      <h3>CORS</h3>
      <p><b>Cross-Origin Resource Sharing</b> (CORS) is a mechanism that, using HTTP headers, gives the browser
        permission to download resources from a specific origin in response to a web application request received from a
        different origin. For security reasons, all browsers stop all HTTP cross requests that are made by client-side
        JavaScript. The CORS mechanism makes secure cross-requests and data transfers between web browsers and web
        servers. For Node.js, this is the CORS module available through the NPM registry.</p>
      <span>
        const <b>cors</b> = require(<b>'cors'</b>); <br>
        app<b>.use(</b>cors( )<b>)</b>;
      </span>
      <p>In the cors middlewarefunction, we can pass a config object argument with the properties. The default
        configuration is equivalent to:</p>
      <span><b>{</b>
        <b>origin</b>: '*',
        <b>methods</b>: 'GET, HEAD, PUT, PATCH, POST, DELETE',
        <b>preflightContinue</b>: false,
        <b>optionsSuccessStatus</b>: 204
        <b>}</b></span>
      <h3>Creating URL for REST API</h3>
      <p>When resources are named correctly, the API is intuitive and easy to use. Often the end URLs for a resource
        request are referred to as <b>API endpoints</b>. you need to use plural nouns to describe base URLs -
        <i>users</i>, <i>contacts</i>. You should also use the more specific and clear names <i>news</i>, <i>videos</i>
        rather than the abstract <i>items</i> or <i>elements</i>.
      </p>
    </section>

    <section class="mongo">
      <a href="#goit">
        <h2 id="mongo">The MongoDB Database <span>(Lesson 5)</span></h2>
      </a>
      <h3>MongoDB Basics</h3>
      <p>MongoDB is a non-relational NoSQL database. The database is based on a document model - data objects are stored
        as individual documents in a collection. Data in MongoDB is grouped into collections. A collection is a group of
        documents that have the same purpose. A collection is similar to a table in an SQL database, but differs in that
        there is no strict schema for the collection and the documents of the collection can have different structures.
        <a href="https://www.mongodb.com/atlas/database" target="_blank" rel="noopener noreferrer"><b>MongoDB
            Atlas</b></a> is a cloud-hosted variant of the MongoDB service and multi-cloud developer data platform.
        There are many graphical MongoDB management tools. These tools increase the productivity of our MongoDB
        development and administration tasks.
      </p>
      <ul>
        <li><a href="https://www.mongodb.com/products/compass" target="_blank" rel="noopener noreferrer"><b>MongoDB
              Compass</b></a> is a graphical interface for MongoDB from the company itself. It has good data
          visualization and has full CRUD functionality.</li>
        <li><a href="https://robomongo.org/" target="_blank" rel="noopener noreferrer"><b>Robo 3T</b></a> is a popular
          free GUI for MongoDB enthusiasts. This lightweight open source tool has cross-platform support and also embeds
          the Mongo shell into its interface to provide both shell-based and GUI-based interaction.</li>
      </ul>
    </section>

    <section class="mongoose">
      <a href="#goit">
        <h2 id="mongoose">ODM Mongoose <span>(Lesson 6)</span></h2>
      </a>
      <h3>Mongoose</h3>
      <p>Mongoose introduces a special ODM (Object Data Modeling) library for working with MongoDB. Most often, the
        Mongoose library serves as a convenient tool for applying a structured schema to a collection in MongoDB.</p>
      <span>const <b>mongoose</b> = require(<b>'mongoose'</b>); <br>
        mongoose<b>.connect(</b>process.env.DB_HOST<b>).then(</b>app.listen(PORT))<b>.catch(</b>err => {
        console.log(err); process.exit(1); }<b>)</b>;
      </span>
      <h3>Document Schema</h3>
      <p>In ODM (Objct Data Modeling) Mongoose data can be described with a specific schema.</p>
      <span>
        const { <b>Schema</b>, <b>model</b> } = require(<b>'mongoose'</b>); <br>
        const <b>schema</b> = new <b>Schema(</b> { <br>
        <b>phone</b>: {
        type: String,
        match: /^\(\d{3}\) \d{3}-\d{4}$/,
        required: true,
        unique: true,
        }, <br>
        <b>favorite</b>: { type: Boolean, default: false }, <br>
        <b>group</b>: {
        type: String,
        enum: groupList,
        required: [true, `Set group`],
        },
        }, <br>
        { <b>versionKey</b>: false, <b>timestamps</b>: true },
        <b>)</b>; <br>

        const Contact = <b>model(</b>'contact', schema<b>)</b>;
      </span>
      <p>The schema contains the metadata of the objects (<i>String</i>, <i>Number</i>, <i>Date</i>, <i>Buffer</i>,
        <i>Boolean</i>, <i>Mixed</i>, <i>Objectid</i>, <i>Array</i>). Built-in validation rules that can be specified in
        the schema (<i>required</i>, <i>unique</i>, <i>min</i>, <i>max</i>, <i>minlength</i>, <i>maxlength</i>,
        <i>enum</i>, <i>match</i>). If a certain field is frequently used when searching for documents, you can assign
        an <i>index</i> to it. Indexing fields allows you to quickly search through these fields. In the schemas that
        the Mongoose module defines, it is possible to add methods. This makes it possible to call predefined methods
        using an object of type Document. To add a method to an object of type <i>Schema</i>, assign a function to the
        <i>Schema.methods</i> property. A typical use case is to create a function that returns the user's full name,
        encrypts the user's password, and so on.
      </p>
      <h3>Data Operations (CRUD)</h3>
      <ol>
        <li>Create <br>
          <b>.create(</b>req.body<b>)</b>
        </li>
        <li>Read <br>
          <b>.find(</b>[query], [options]<b>)</b> <br>
          <b>.findOne(</b>[query], [options]<b>)</b> <br>
          <b>.findById(</b>req.params.id<b>)</b>
        </li>
        <li>Update <br>
          <b>.findByIdAndUpdate(</b>id, req.body, { new: true }<b>)</b> <br>
          <b>.findOneAndUpdate(</b>[query], [update], [options]<b>)</b>;
        </li>
        <li>Delete <br>
          <b>.findByIdAndDelete(</b>req.params.id<b>)</b> <br>
          <b>.findOneAndRemove(</b>[query], [options]<b>)</b>
        </li>
      </ol>
    </section>

    <section class="auth">
      <a href="#goit">
        <h2 id="auth">Authentication and authorization <span>(Lesson 7-8)</span></h2>
      </a>
      <h3>JSON Web Tokens</h3>
      <p><b>JSON Web Token</b> (<a href="https://jwt.io/" target="_blank" rel="noopener noreferrer">JWT</a>) in its
        simplest form is a secure URL string containing an encoded JSON object. The token contains three parts
        (<i>header, payload, signature</i>), which are separated by a dot "." JWT is an open industry standard, fully
        described in RFC 7519. To create jwt tokens is used the npm package
        <a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank"
          rel="noopener noreferrer"><b>jsonwebtoken</b></a>, which will encrypt and decrypt jwt tokens.
      </p>
      <span>
        const <b>jwt</b> = require(<b>'jsonwebtoken'</b>); <br>
        const <b>payload</b> = { id: 123456, username: 'Larson' }; <br>
        const { <b>SECRET_KEY</b> } = process.env; <br>
        const <b>token</b> = jwt<b>.sign(</b>payload, SECRET_KEY, { expiresIn: '23h' }<b>)</b>; <br>
        await User.findByIdAndUpdate(user._id, { <b>token</b> }); <br>
        const { id } = jwt<b>.verify(</b>token, SECRET_KEY<b>)</b>;
      </span>
      <h3>Authentication with JWT</h3>
      <p>Authentication using JWT, which is mainly used when developing API, which in turn will be used by a web
        application on some modern framework like React, Angular, Vue.js or a similar front-end framework. The web
        application will send a jwt token with each request, which means we do not use a session as in the previous
        local strategy, but simply put a token in every request we make to the API.</p>
      <ul>
        <li>
          <p>
            <b>app.js</b> <br>
            app.use('/api/auth', <b>authRouter</b>);
          </p>
        </li>
        <li>
          <p>
            <b>routes</b>/api/auth.js <br>
            router.post(<b>'/register'</b>, validateBody(schemas<b>.registerSchema</b>),
            ctrlWrapper(auth<b>.register</b>)); <br>
            router.post(<b>'/login'</b>, validateBody(schemas<b>.loginSchema</b>), ctrlWrapper(auth<b>.login</b>)); <br>
            router.get(<b>'/current'</b>, authenticate, ctrlWrapper(auth<b>.getCurrent</b>)); <br>
            router.post(<b>'/logout'</b>, authenticate, ctrlWrapper(auth<b>.logout</b>));
          </p>
        </li>
        <li>
          <p>
            <b>routes</b>/api/contacts.js <br>
            router.use(<b>authenticate</b>); <br>
            router.get(<b>'/'</b>, ctrlWrapper(contacts<b>.getAll</b>)); <br>
            router.get(<b>'/:id'</b>, isValidId, ctrlWrapper(contacts<b>.getById</b>)); <br>
            router.post(<b>'/'</b>, validateBody(schemas.addSchema), ctrlWrapper(contacts<b>.add</b>));
            <br>
            router.put(<b>'/:id'</b>, isValidId, validateBody(schemas.addSchema),
            ctrlWrapper(contacts<b>.updateById</b>)); <br>
            router.patch( <b>'/:id/favorite'</b>, isValidId, validateBody(schemas.updateFavoriteSchema),
            ctrlWrapper(contacts<b>.updateFavoriteById</b>)); <br>
            router.delete(<b>'/:id'</b>, isValidId, ctrlWrapper(contacts<b>.removeById</b>));
          </p>
        </li>
        <li>
          <p>
            <b>models</b>/user.js <br>
            const <b>userSchema</b> = new <b>Schema( {</b> <br>
            <b>name</b>: { type: String, required: true, minlength: 3, unique: true, }, <br>
            <b>email</b>: { type: String, match: emailRegex, required: true, unique: true, }, <br>
            <b>password</b>: { type: String, required: true, minlength: 6, }, <br>
            <b>token</b>: { type: String, default: null, }, <br>
            }, { <b>versionKey</b>: false, <b>timestamps</b>: true }, <b>)</b>; <br>

          <p>userSchema<b>.post(</b>'save', mongooseError<b>)</b>;</p>

          const <b>loginSchema</b> = Joi.object({ // ... }); <br>
          const <b>registerSchema</b> = Joi.object({ <br>
          name: Joi.string( ).min(3).required( ), <br>
          email: Joi.string( ).pattern(emailRegex).message('Invalid email!').required( ), <br>
          password: Joi.string( ).min(6).required( ), }); <br>
          <p>
            const <b>schemas</b> = { registerSchema, loginSchema }; <br>
            const <b>User</b> = model(<b>'user'</b>, <b>userSchema</b>);
          </p>
          </p>
        </li>
        <li>
          <p>
            <b>models</b>/contact.js <br>
            const <b>contactSchema</b> = new <b>Schema</b> ( { ...,
            <b>owner</b>: { type: Schema.Types.ObjectId, ref: <b>'user'</b>, required: true } } <b>)</b>;
        </li>
        <li>
          <p>
            <b>controllers</b>/auth.js <br>
            const <b>bcrypt</b> = require(<b>'bcryptjs'</b>); <br>
            const <b>jwt</b> = require(<b>'jsonwebtoken'</b>); <br>
            const { <b>User</b> } = require('../models/user'); <br>
            const { <b>HttpError</b> } = require('../helpers');
          <ul>
            <li>
              const <b>register</b> = <b>async (</b>req, res<b>) => {</b> <br>
              const { name, email, password } = req.body; <br>
              if (await User.findOne({ <b>name</b> })) throw HttpError(409, 'Name already exists'); <br>
              if (await User.findOne({ <b>email</b> })) throw HttpError(409, 'Email already exists'); <br>
              const <b>hashPassword</b> = await <b>bcrypt.hash(</b>password, 10<b>)</b>; <br>
              const <b>newUser</b> = await User<b>.create(</b>{ ...req.body, password: hashPassword }<b>)</b>; <br>
              res.status(201).json({ name: newUser.name, email: newUser.email }); <b>}</b>;
            </li>
            <li>
              const <b>login</b> = <b>async (</b>req, res<b>) => {</b> <br>
              const { email, password } = req.body; <br>
              const <b>user</b> = await User.findOne({ email });
              if (<b>!user</b>) throw HttpError(401, 'User or password invalid'); <br>

              const <b>isMatch</b> = await <b>bcrypt.compare(</b>password, user.password<b>)</b>;
              if (<b>!isMatch</b>) throw HttpError(401, 'User or password invalid'); <br>

              const <b>token</b> = <b>jwt</b>.sign({ id: user._id }, SECRET_KEY, { expiresIn: '23h' }); <br>
              await User.findByIdAndUpdate(user._id, { <b>token</b> }); <br>
              res.json({ token }); <b>}</b>;
            </li>
            <li>
              const <b>getCurrent</b> = <b>async (</b>req, res<b>) => {</b>
              const { name, email } = req.user;
              res.json({ <b>name</b>, <b>email</b> }); <b>}</b>;
            </li>
            <li>
              const <b>logout</b> = <b>async (</b>req, res<b>) => {</b>
              await User.findByIdAndUpdate(req.user._id, { <b>token</b>: null });
              res.status(204); <b>}</b>;
            </li>
          </ul>
          </p>
        </li>
        <li>
          <p>
            <b>helpers</b>/mongooseError.js <br>
            const <b>isUnuqueConflict</b> = ({ <b>name</b>, <b>code</b> }) =>
            name === <b>'MongoServerError'</b> && code === <b>11000</b>; <br>

            const <b>mongooseError</b> = <b>(</b>error, data, next<b>) => {</b>
            error<b>.status</b> = isUnuqueConflict(error) ? <b>409</b> : <b>400</b>;
            next( ); <b>}</b>;
          </p>
        </li>
        <li>
          <p>
            <b>helpers</b>/ctrlWrapper.js <br>
            const <b>ctrlWrapper</b> = ctrl <b>=> {</b> <br>
            return <b>async (</b>req, res, next<b>) => {</b> <br>
            <b>try</b> { await ctrl(req, res, next); } <br>
            <b>catch</b> (error) { next(error); } <b>}</b>; <b>}</b>;
          </p>
        </li>
        <li>
          <p>
            <b>middlewares</b>/isValidId.js <br>
            const <b>isValidId</b> = <b>(</b>req, res, next<b>) => {</b>
            const { id } = req.params; <br>
            <b>if</b> (!isValidObjectId(id)) { next(HttpError(400)); } <br>
            next( ); <b>}</b>;
          </p>
        </li>
        <li>
          <p>
            <b>middlewares</b>/validateBody.js <br>
            const <b>validateBody</b> = schema <b>=> {</b> <br>
            <b>return (</b>req, res, next) <b>=> {</b>
            const { error } = schema.validate(req.body); <br>
            <b>if</b> (error) { next(HttpError(400, error.message)); } <br>
            next( ); <b>}</b>; <b>}</b>;
          </p>
        </li>
        <li>
          <p>
            <b>middlewares</b>/authenticate.js <br>
            const <b>authenticate</b> = <b>async (</b>req, res, next<b>) => {</b> <br>
            const { authorization = '' } = req.headers; <br>
            const [<b>bearer</b>, <b>token</b>] = authorization.split(' '); <br>
            <b>if (</b>bearer !== <b>'Bearer'</b><b>) {</b> next(HttpError(401)); <b>}</b> <br>
            <b>try {</b> <br>
            const { id } = <b>jwt.verify(</b>token, SECRET_KEY<b>)</b>; <br>
            const <b>user</b> = await User<b>.findById(</b>id<b>)</b>; <br>
            <b>if (</b>!user || !user.token || user.token !== token<b>) {</b> next(HttpError(401)); <b>}</b> <br>
            req.user = user; <br>
            next( ); <br>
            <b>} catch {</b> <br>
            next(HttpError(401)); <b>} }</b>;
          </p>
        </li>
      </ul>
    </section>

    <section class="files">
      <a href="#goit">
        <h2 id="files">Work with files <span>(Lesson 9)</span></h2>
      </a>
      <h3>File upload</h3>
      <p>The HTML form sent to the server by the browser must be encoded. If we don't specify an encoding method, the
        default is <i> application/x-www-form-urlencoded</i>. But if it becomes necessary to upload files to the server,
        the task becomes a little more difficult. We need to use the <i>multipart/form-data encoding</i> type to send
        files. There are <a href="https://github.com/expressjs/multer" target="_blank"
          rel="noopener noreferrer"><b>Multer</b></a> and <a href="https://github.com/node-formidable/formidable"
          target="_blank" rel="noopener noreferrer"><b>Formidable</b></a> packages for uploading files to the server.
        After we process the form, we need to return the response to the browser. We can send the HTML or JSON directly
        to the browser or client. Or we can use mainly two response codes (302 or 303). <b>Multer</b> is an Express
        framework middleware that is used when uploading files to process <i>multipart/form-data</i>. Multer adds a body
        object and a file (or files) object inside the request object. The body object contains the values of
        the form's text fields, the <b>file</b> object (<b>files</b>) contains the file or files uploaded via the form.
      </p>
      <span>
        app.js <br>
        app.use(express<b>.static(</b>'public'<b>)</b>);
      </span>
      <p>
        <b>middlewares</b>/upload.js <br>
        const <b>multer</b> = require(<b>'multer'</b>); <br>
        const multerConfig = multer<b>.diskStorage(</b>{ <br>
        <b>destination</b>: path.join(__dirname, '..', 'temp'), <br>
        <b>filename</b>: (req, file, cb) => { cb(null, file.originalname); }, <br>
        <b>limits</b>: { fileSize: 2048 }, }<b>)</b>; <br>
        const upload = <b>multer(</b>{ storage: multerConfig }<b>)</b>;
      </p>
      <span>
        <b>routes</b>/api/users.js <br>
        router.patch('/avatars', authenticate, <b>upload.single(</b>'avatar'<b>)</b>, ctrlWrapper(users.updateAvatar));
      </span>
    </section>

    <section class="testing">
      <a href="#goit">
        <h2 id="testing">Testing of Applications <span>(Lesson 10)</span></h2>
      </a>
      <h3>Technology stack for unit testing</h3>
      <p>A large application always has a high probability of errors. Without testing, the application is often checked
        manually, and if the application is old and has vast functionality, then sometimes it looks like a black box.
        This is where automated testing of application functionality comes to the rescue. Testing is when we write code
        that automatically checks for errors when we make changes to our application. Accordingly, the approach of
        writing tests are divided into two types: <b>Code first</b> and <b>Test first</b>. The testing pyramid is used
        to distribute tests across application tiers. The bottom of the pyramid is covered by <b>unit tests</b>. They
        are written primarily by developers and cover atomic components such as classes, methods, and functions. Then go
        an <b>integration tests</b> to check if the new implemented functionality has broken the application code. At
        the top there are<b> UI</b> and <b>manual tests</b>.
      </p>
      <h3>Jest</h3>
      <p>Testing libraries are special tools that help in the testing process. The <a href="https://jestjs.io/"
          target="_blank" rel="noopener noreferrer"><b>Jest</b></a> library will cover any task that may arise when
        testing our application. It is a command line tool built on top of Jasmine, another popular testing library.
        Jest is developed by Facebook, and Jest is often used alongside React. The <b>describe</b> command defines a set
        of tests. It is used as a container for the test suite. The <b>test</b> (or <b>it</b>) command is used for a
        single test or otherwise a test case. Other constructs such as <b>beforeAll</b>, <b>afterAll</b>,
        <b>beforeEach</b> and <b>afterEach</b>, as the name suggests, are executed before or after a test suite or test
        case. Tests must contain at least one <i>describe</i> and <i>test</i> commands.
      </p>
    </section>

    <section class="email-docker">
      <a href="#goit">
        <h2 id="email-docker">Work with email and Docker <span>(Lesson 11)</span></h2>
      </a>
      <h3>Nodemailer Package</h3>
      <p>const <b>nodemailerCofig</b> = <b>{</b> <br>
        <b>host</b>: 'smtp.meta.ua', <b>port</b>: '465', <b>secure</b>: true, <br>
        <b>auth</b>: { user: 'it.dev@meta.ua', pass: META_PASS, }, <b>}</b>; <br>
      </p>
      <span>
        const <b>transporter</b> = nodemailer<b>.createTransport(</b>nodemailerCofig<b>)</b>; <br>
        await transporter<b>.sendMail(</b>{
        <b>from</b>: 'it.test@meta.ua',
        <b>to</b>: 'noresponse@gmail.com',
        <b>subject</b>: 'test',
        <b>text</b>: 'Hello, World!',
        }<b>)</b>;
      </span>

      <h3>Docker</h3>
      <p>The core function of <a href="https://hub.docker.com/" target="_blank"
          rel="noopener noreferrer"><b>Docker</b></a> is to build, ship, and run software anywhere Docker exists. For
        the user, most often Docker is a command line program that they run. The <a
          href="https://hub.docker.com/r/portainer/portainer-ce" target="_blank"
          rel="noopener noreferrer"><b>Portainer</b></a> allows you to manage all your orchestrator resources
        (containers, images, volumes, networks and more) through a ‘smart’ GUI and/or an extensive API. </p>
      <ul>
        <li>docker <b>login</b> - to login in Dockerhub;</li>
        <li>docker <b>version</b> - to verify that the Docker version;</li>
        <li>docker <b>pull</b> image:tag - to download on Dockerhub Docker-image;</li>
        <li>docker <b>push</b> image:tag - to upload Docker-image;</li>
        <li>docker <b>run</b> [options] image:tag [command, args] - to run a Docker image as a container, where
          arguments:
          <ul>
            <li><b>--rm</b> - removes container after stop;</li>
            <li><b>--name</b> - creates name for container;</li>
            <li><b>-d</b> - switches the command from interactive mode;</li>
            <li><b>-p</b> 80:3000 - defines ports;</li>
            <li><b>-e</b> VAR_NAME - to define ENV variables manually;</li>
            <li><b>--env-file</b> path - to run ENV variables manually from .env file;</li>
          </ul>
        </li>
        <li>docker <b>ps</b> [options] - to list running containers, where arguments:
          <ul>
            <li><b>--all</b> - to list containers;</li>
          </ul>
        </li>
        <li>docker <b>rm</b> - removes container;</li>
        <li>docker <b>rmi</b> - removes image;</li>
        <li>docker <b>container prune</b> - removes all container;</li>
        <li>docker <b>tag</b> imageID name[:tag] - to name container;</li>
        <li>docker <b>images</b> - to list images;</li>
        <li>docker <b>image</b> [options] - to work with image, where arguments:
          <ul>
            <li><b>inspect</b> imageID - to inspect image;</li>
            <li><b>ls</b> - to list images;</li>
          </ul>
        </li>
        <li>docker <b>commit</b> [options] container [repository:tag] - to create a new image with all the changes made
          in the container;</li>
        <li>docker <b>build</b> [options] path - to create a new image, where arguments:
          <ul>
            <li><b>-t</b> name[:tag] - to name container;</li>
          </ul>
        </li>
      </ul>
      <p>To make a new image a Dockerfile in the same folder as the file package.json with the following
        contents must be created:</p>
      <ul>
        <li><b>FROM</b> node:17.9.1</li>
        <li><b>WORKDIR</b> /app</li>
        <li><b>COPY</b> package.json /app</li>
        <li><b>RUN</b> npm install</li>
        <li><b>COPY</b> . .</li>
        <li><b>ENV</b> PORT=3000</li>
        <li><b>ENV</b> SECRET_KEY qweqweasdasd</li>
        <li><b>EXPOSE</b> $PORT</li>
        <li><b>CMD</b> ["npm", "start"]</li>
      </ul>
      <p>To ignoring COPY some files <b>.dockignore</b> file must be created:</p>
      <span>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ <b>⁣⁣⁣⁣Dockerfile</b> <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ <b>⁣⁣⁣⁣node_modules</b> <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣<b>⁣.git</b> <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣<b>⁣.env</b>

      </span>
      <p>To run a Docker image as a container you can install <a href="https://docs.docker.com/compose/" target="_blank"
          rel="noopener noreferrer"><b>Docker Compose</b></a> and use <b>docker-compose.yml</b> file with command
        <i>docker-compose up [-d]</i> to run:
      </p>
      <span>
        <b>version</b>:"0.1" <br>
        <b>services</b>: <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣srviceName: <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣<b>image</b>: imageName <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣<b>container_name</b>: containerName <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣<b>volumes</b>: 'volumesNames' <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣<b>environment</b>: <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣- 'SECRET_KEY=qweasd' <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣- 'PORT=3001' <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣<b>ports</b>: <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣- '80:PORT' <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣- '443:443' <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣<b>restart</b>: unless-stopped [always] / [no] / [on-failure] <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣<b>networks</b>: <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣default: <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣driver: bridge <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣name: webnet <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ <b>⁣⁣⁣depends_on</b>: <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣- srviceName_1 <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣⁣⁣- srviceName_2
      </span>
    </section>

    <section class="websockets">
      <a href="#goit">
        <h2 id="websockets">Websockets <span>(Lesson 12)</span></h2>
      </a>
      <h3>Module ws</h3>
      <p>WebSocket is a bidirectional communication protocol that characterizes the full duplex nature of communication.
        It establishes one, and only one, connection between a client and a server, the server and client can send text
        messages through it, and the transfer occurs immediately. In order to start working with web sockets, you need
        only two things - a browser that supports <b>WebSocket</b>, and a server that implements this technology. On the
        server, you need to install the appropriate module:</p>
      <span>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣const <b>ws</b> = <b>new</b> require(<b>'ws'</b>); <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣const <b>wsServer</b> = <b>new</b> ws<b>.Server(</b>{ port: 8080 }<b>)</b>;
        <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣wsServer<b>.on(</b>'connection', ws => { ws<b>.send(</b>'Welcome'<b>)</b>;
        console.log('New connection'); }<b>)</b>;
      </span>
      <p>Then you need to write a small client - a web page hosted on a regular web server:</p>
      <span>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣&#60script> <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣const <b>ws</b> = new <b>WebSocket(</b>"ws://localhost:4000"<b>)</b> <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ws<b>.onopen</b> = ( ) => <b>{</b> console.log('Connected'); <b>}</b>;<br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ws<b>.onmessage</b> = e => <b>{</b> console.log(e.data); <b>}</b>;
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣setTimeout(( ) => { ws<b>.send(</b>'Great to see you!'<b>)</b>; }, 2000)
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣&#60/script>
      </span>
      <h3>Socket.io</h3>
      <p>This library provides real-time and event-based two-way communication.</p>
      <span>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣const { <b>Server</b> } = require(<b>'socket.io'</b>);<br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣const { <b>createServer</b> } = require(<b>'http'</b>); <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣const <b>httpServer</b> = createServer(); <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣const <b>io</b> = new <b>Server(</b>httpServer, { cors: { origin: '*' } }<b>)</b>; <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣io<b>.on(</b><b>'connection'</b>, socket => {console.log('Connected!'<b>)</b>;
        socket<b>.emit(</b>'message', 'User connected!'); }<b>)</b>; <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣http<b>.listen(</b>3000, ( ) => { console.log('Listening on *:3000'); }<b>)</b>;
      </span>

      <p>In the frontend we will place the <b>App.js</b> file, which will be our client part:</p>
      <span>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣import <b>io</b> from <b>'socket.io-client'</b>; <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣const <b>socket</b> = io<b>.connect(</b>'http://localhost:3001'<b>)</b>; <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣socket<b>.on(</b>'message', data => { console.log(data); }<b>)</b>; <br>
        ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣socket<b>.emit(</b>'message', 'User connected!')<b>)</b>;
      </span>
      <p>The idea of ​​building socket.io applications is that both its parts - server and client - have the same
        properties and methods, but they have a different list of event handlers.</p>
      <ul>
        <li>The server events:
          <ul>
            <li><b>connection</b> - the event occurs when a connection is established with the client;</li>
            <li><b>message</b> - the event occurs when a message is received from the client;</li>
            <li><b>disconnect</b> - disconnection;</li>
            <li><b>anything</b> - to create custom events.</li>
          </ul>
        </li>
        <li>The browser part events:
          <ul>
            <li><b>connecting</b> - the event occurs in the process of establishing a connection with the server;
            </li>
            <li><b>connect_failed</b> - the event occurs when a connection attempt fails;</li>
            <li><b>connect</b> - the event occurs when a connection is established with the server;</li>
            <li><b>message</b> - the event occurs when a message is received from the server;</li>
            <li><b>disconnect</b> - the event occurs when the connection to the server is disconnected;</li>
            <li><b>reconnecting</b> (may occur repeatedly) - the event occurs when an attempt is made to restore the
              connection;</li>
            <li><b>reconnect</b> - the event occurs when the connection is restored;</li>
            <li><b>error</b> - error events;</li>
            <li><b>anything</b> - any event.</li>
          </ul>
        </li>
      </ul>
    </section>


    <section class="websockets">
      <a href="#goit">
        <h2 id="extra">Extra Materials <span>(Additional)</span></h2>
      </a>







      ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣ ⁣ ⁣⁣⁣ ⁣⁣⁣ ⁣⁣
    </section>
  </main>

  <footer></footer>
</body>

</html>