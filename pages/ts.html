<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TS</title>

  <link rel="stylesheet" href="../css/index.min.css">
</head>

<body>
  <header id="goit" class="header container">
    <nav class="nav">
      <ul class="nav__list">
        <li><a href="../index.html">Main</a></li>
        <li><a href="../pages/html-css.html">HTML-CSS</a></li>
        <li><a href="../pages/js.html">JS</a></li>
        <li><a href="../pages/ts.html">TS</a></li>
        <li><a href="../pages/react.html">React</a></li>
        <li><a href="../pages/react-nat
        <li><a href=" ../pages/next.html">Next.js</a></li>
        <li><a href="../pages/node.html">Node.js</a></li>
        <!-- <li><a href=""></a></li> -->
        <li><a href="../pages/terminal.html">terminal</a></li>
        <li><a href="" target="_blank" rel="noopener noreferrer nofollow">GoIT</a></li>
        <li><a href="https://github.com/Belka-S?tab=repositories" target="_blank"
            rel="noopener noreferrer nofollow">GitHub</a></li>
        <li><a href="https://dashboard.render.com/" target="_blank">Render</a></li>
        <li><a href="https://chat.openai.com/chat" target="_blank" rel="noopener noreferrer nofollow">OpenAI</a></li>
      </ul>
    </nav>
  </header>

  <main class="container">
    <section>
      <div class="goit">
        <h2><a href="https://www.typescriptlang.org/docs/" target="_blank"
            rel="noopener noreferrer nofollow">TypeScript</a></h2>
        <ul class="goit__contents">
          <li><a href="#basics">Basics <span>(Lesson 1)</span>
              <div>
                <a href="https://youtu.be/30LWjhZzg50" target="_blank" rel="noopener noreferrer">TS (freeCodeCamp)</a>
                <a href="https://youtu.be/gieEQFIfgYc" target="_blank" rel="noopener noreferrer">TS (Dave Gray)</a>
              </div>
            </a></li>
          <li><a href="#types">Types <span>(Lesson 2)</span></a>
            <div>
              <a href="https://youtu.be/V8tefDOdw2w" target="_blank">TS-1 (Melnik)</a>
              <a href="https://youtu.be/h2IBxOaUIf0" target="_blank">TS-2 (Melnik)</a>
            </div>
          </li>
          <li><a href="#oop">OOP <span>(Lesson 3)</span></a>
            <div>
              <a href="https://youtu.be/aKZRBk0u2wE?list=PLGS5TF12xmz81204LuIeraH9YFUEfFSgd" target="_blank"
                rel="noopener noreferrer">TS-Classes</a>
            </div>
          </li>
          <li><a href="#react">React <span>(Lesson 4)</span></a>
            <div>
              <a href="https://youtu.be/Em3j7rdM3SA" target="_blank">TS-3 (Melnik)</a>
              <a href="https://youtu.be/0lCPZwDCOd0" target="_blank">React TS (Repeta)</a>
              <a href="https://www.youtube.com/watch?v=92qcfeWxtnY" target="_blank">20min TS </a>
              <a href="https://youtu.be/j-LxLzYgpX4" target="_blank">45min TS</a>
            </div>
          </li>
          <li><a href="#decorators">Decorators <span>(Lesson 5)</span></a>
            <div>
              <a href="" target="_blank">1-Node <span></span></a>
            </div>
          </li>
          <li><a href="#nodejs">Node.js <span>(Lesson 6)</span></a>
            <div>
              <a href="" target="_blank">2-Node <span></span></a>
            </div>
          </li>
        </ul>
      </div>
    </section>
    <section class="basics">
      <a href="#goit">
        <h2 id="basics">Basics <span>(Lesson 1)</span></h2>
      </a>

      <h3>Install</h3>
      <ul>
        <li><b>npm install -g typescript</b> - install</li>
        <li><b>tsc [-w]</b> - run a compile based on a backwards look through the fs for a tsconfig.json</li>
      </ul>

      <a href="https://www.typescriptlang.org/tsconfig" target="_blank" rel="noopener noreferrer">
        <h3>tsconfig.json</h3>
      </a>
      <span>
        "compilerOptions": { <br>
        "rootDir": "./src", <br>
        "outDir": "./dist", <br>
        "allowJs": false, <br>
        "allowSyntheticDefaultImports": true, <br>
        "emitDecoratorMetadata": true, <br>
        "esModuleInterop": true, <br>
        "experimentalDecorators": true, <br>
        "lib": ["dom", "ES2021"], <br>
        "module": "es2020", <br>
        "moduleResolution": "node", <br>
        "preserveConstEnums": true, <br>
        "skipLibCheck": true, <br>
        "strictNullChecks": true, <br>
        "target": "es2019", <br>
        "sourceMap": true <br>
        }, <br>
        "include": ["**/*.ts", "**/*.tsx"], <br>
        "exclude": ["node_modules/**/*"]
      </span>
    </section>

    <section class="types">
      <a href="#goit">
        <h2 id="types">Types <span>(Lesson 2)</span></h2>
      </a>

      <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html" target="_blank"
        rel="noopener noreferrer">
        <h3>Basic Types</h3>
      </a>
      <ul>
        <li><b>number</b>
          <ul>
            <li>let float: number = 3.14</li>
          </ul>
        </li>
        <li><b>string</b>
          <ul>
            <li>let color: string = "blue"</li>
          </ul>
        </li>
        <li><b>boolean</b>
          <ul>
            <li>let isDone: boolean = false</li>
          </ul>
        </li>
        <li><b>null</b>
          <ul>
            <li>let empty: null = null</li>
          </ul>
        </li>
        <li><b>undefined</b>
          <ul>
            <li>let notParam: undefined = undefined</li>
          </ul>
        </li>
        <li><b>object</b>
          <ul>
            <li>const obj: object = { }</li>
            <li>const obj: { } = { };</li>
            <li><b>type</b> User = { name: string; age: number; };</li>
            <li><b>interface</b> User = { name: string; age: number; };</li>
          </ul>
        </li>
        <li><b>Array</b>
          <ul>
            <li>let arrString: string[ ]</li>
            <li>let matrix: number[ ][ ] = [[1, 2], [3, 4]];</li>
            <li>
              type User = { name: string; age: number; }; <br>
              let users: User[ ]</li>
          </ul>
        </li>
      </ul>

      <a href="#types">
        <h3>Variables and Arguments</h3>
      </a>
      <ul>
        <li><b>any</b>
          <ul>
            <li>let data: <b>any</b> = fetchData( )</li>
          </ul>
        </li>
        <li><b>unknown</b> <i>(to check type <b>as</b>, <b>typeof</b>, <b>instanceof</b>)</i>
          <ul>
            <li>let userData: <b>unknown</b> = fetchUserData( );
            </li>
          </ul>
        </li>
        <li><b>enum</b> <i>(bool, any - are not allowed)</i>
          <ul>
            <li><b>enum</b> Role {ADMIN, USER}; <br>
              const person = { role: Role.ADMIN, }; <br>
              if (person.role === Role.ADMIN) { console.log('Role: ', Role.ADMIN); }</li>
            <li>
              <b>enum</b> UserStatus { Active = 'ACTIVE', Inactive = 'INACTIVE', } <br>
              let status: UserStatus = UserStatus.Active;
            </li>
            <li>
              <b>enum</b> Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat, }; <br>
              const isWeekend = (day: <b>keyof typeof</b> Day): boolean => <br>
              day === 'Sun' || day === 'Sat' ? true : false; <br>
              isWeekend('Sun')
            </li>
            <li>console.log(Role[Role.ADMIN]); // "ADMIN"</li>
          </ul>
        </li>
        <li><b>tuple</b>
          <ul>
            <li>let tuple: <b>[</b>string, boolean<b>]</b></li>
            <li>let tuple: <b>[</b>string, ...number[ ]<b>]</b></li>
          </ul>
        </li>
        <li><b>union</b>
          <ul>
            <li>let mixedType: string <b>|</b> number <b>|</b> boolean</li>
            <li>or let pet: Dog <b>|</b> Fish</li>
          </ul>
        </li>
        <li>intersection <b>&</b> <i>(must contain all properties defined)</i>
          <ul>
            <li>type Employee = { name: string; id: number; }; <br>
              type Manager = { employees: Employee[ ]; }; <br>
              type CEO = Employee <b>&</b> Manager;</li>
          </ul>
        </li>
        <li><b>literal</b>
          <ul>
            <li>type size = 'small' <b>|</b> 'medium' <b>|</b> 'large'</li>
          </ul>
        </li>
      </ul>

      <a href="#types">
        <h3>Methods and Functions</h3>
      </a>
      <ul>
        <li><b>function</b>, <i>optional argument</i> <b>?</b>
          <ul>
            <li>let myFunc: (firstArg: string, secondArg<b>?</b>: number) => void</li>
            <li>let myFunc: (...params: any[ ]) => void</li>
            <li>type CallbackType = (num1: number, num2<b>?</b>: number) => number;</li>
            <li>type CallbackType = (...nums: number[ ]) => number;</li>
          </ul>
        </li>
        <li>function <b>return</b>
          <ul>
            <li>function greet( ): string { return "Hello, world!"; }</li>
            <li>const greet = ( ): string => { return "Hello, world!"; }</li>
          </ul>
        </li>
        <li><b>void</b> <i>(absence of any type)</i>
          <ul>
            <li>const greet = ( ): <b>void</b> => { console.log("Hello, world!"); }</li>
            <li>function doSomething(callback: ( ) => <b>void</b>) { callback( ); }</li>
          </ul>
        </li>
        <li><b>never</b> (infinite loop, <b>listen( )</b> method from Express, <b>throw new Error( )</b>)
          <ul>
            <li>function throwError(message: string): <b>never</b> { throw new Error(message); }</li>
            <li>function infiniteLoop( ): <b>never</b> { while (true) { } }</li>
          </ul>
        </li>
      </ul>


      <a href="#types">
        <h3>Custom Types</h3>
      </a>
      <ul>
        <li><b>type</b>, <i>optional property</i> <b>?</b>
          <ul>
            <li><b>type</b> Animal = { name: string; }</li>
            <li><b>type</b> Coordinate = [number, number]; <br>
              <b>type</b> UserWithCoords = {
              id: number;
              name: string;
              coords<b>?</b>: Coordinate; };
            </li>
            <li>enum AnimalIds {
              cat = 'cat',
              dog = 'dog', } <br>
              <b>type</b> Animal = {
              [AnimalIds.cat]: {
              meow: ( ) => string;
              };
              [AnimalIds.dog]: {
              bark: ( ) => string;
              }; };
            </li>
            <li><b>type</b> Cat = { meow: ( ) => string; }; <br>
              interface Dog { bark: ( ) => string; }; <br>
              <b>type</b> DogOrCat = Dog <b>|</b> Cat; <br>
              <b>type</b> DogAndCat = Dog <b>&</b> Cat;
            </li>
          </ul>
        </li>
        <li><b>interface</b>, <i>optional property</i> <b>?</b>, <b>implements</b> <i>(to check that a class satisfies a
            particular interface)</i>
          <ul>
            <li><b>interface</b> Animal { name: string; } <br>
              <b>interface</b> Animal { age<b>?</b>: number; } <br>
              let dog: Animal = {name: 'Fido',age: 5,};
            </li>
            <li>
              <b>interface</b> Animal { name: string; }; <br>
              <b>interface</b> Dog <b>extends</b> Animal { bark: string; }; <br>
              class MyDog <b>implements</b> Dog { name = 'Fido'; bark = 'Woof!'; }
            </li>
            <li><b>interface</b> AddFunc { (n1: number, n2: number): number; }</li>
          </ul>
        </li>
      </ul>


      <a href="#types">
        <h3>Advanced Types (Type Guards)</h3>
      </a>
      <ul>
        <li><b>typeof</b>
          <ul>
            <li>type ComplexType = string | number;<br>

              function combine(a: ComplexType, b: ComplexType) { <br>
              if (<b>typeof</b> a === 'number' || <b>typeof</b> b === 'number') { return a + b; } <br>
              return a.toString( ) + b.toString( ); }</li>
          </ul>
        </li>
        <li><b>keyof</b>
          <ul>
            <li>
              type Person = { name: string; age: number; };<br>
              type PersonKeys = <b>keyof</b> Person;
            </li>
          </ul>
        </li>
        <li><b>in</b>
          <ul>
            <li>
              type Admin = { name: string; privileges: string[ ]; }; <br>
              type Employee = { name: string; startDate: Date; }; <br>
              type AdminOrEmployee = Admin | Employee; <br>
              function printDetails(obj: AdminOrEmployee) { console.log(`Name: ${obj.name}`); <br>
              if ('privileges' <b>in</b> obj) { console.log(`Privileges: ${obj.privileges.join(', ')}`); } }
            </li>
            <li>
              type Dog = { bark: ( ) => void; }; <br>
              type Cat = { meow: ( ) => void; }; <br>

              function isDog(animal: Dog | Cat): animal is Dog { return 'bark' <b>in</b> animal; } <br>

              function letAnimalTalk(animal: Dog | Cat) { <br>
              if (isDog(animal)) { animal.bark( ); } else { animal.meow( ); } }
            </li>
          </ul>
        </li>
        <li><b>instanceof</b>
          <ul>
            <li>
              class Car { drive( ) { console.log('Driving a car...'); } }; <br>
              class Truck { drive( ) { console.log('Driving a truck...'); } <br>
              loadCargo(amount: number) { console.log(`Loading cargo: ${amount}`); } }; <br>

              type Vehicle = Car | Truck; <br>
              const carInstance = new Car( ); <br>
              const truckInstance = new Truck( ); <br>
              function useVehicle(vehicle: Vehicle) { vehicle.drive( ); <br>
              if (vehicle <b>instanceof</b> Truck) { vehicle.loadCargo(1000); } } <br>
            </li>
          </ul>
        </li>
        <li><b>as</b>
          <ul>
            <li>
              type Admin = { name: string; privileges: string[ ]; }; <br>
              type Employee = { name: string; startDate: Date; }; <br>
              type Staff = Admin | Employee; <br>

              function isEmployee(staff: Staff): staff <b>is</b> Employee { <br>
              return (staff <b>as</b> Employee).startDate !== undefined; } <br>
              const staffMember: Staff = { name: 'Bob', startDate: new Date( ) }; <br>

              if (isEmployee(staffMember)) { console.log( <br>
              `Welcome, ${staffMember.name}! Start date is ${staffMember.startDate}` ); }
            </li>
          </ul>
        </li>
        <li><b>&#60></b> <i>(Type Conversion - to convert to another type)</i>
          <ul>
            <li>
              let someValue: unknown = 'this is a string'; <br>
              let strLength: number = (<b>&#60</b>string<b>></b>someValue).length;
            </li>
            <li>const input = <b>&#60</b>HTMLInputElement<b>></b>document.getElementById('inputEmail');</li>
          </ul>
        </li>
        <li><b>as</b> <i>(Type Conversion - to convert to another type)</i>
          <ul>
            <li>
              let someValue: unknown = 'this is a string'; <br>
              let strLength: number = (someValue <b>as</b> string).length;
            </li>
            <li>const input = document.getElementById('inputEmail') <b>as</b> HTMLInputElement;</li>
          </ul>
        </li>
        <li><b>extends</b> <i>(to define constraints on types)</i>
          <ul>
            <li>function merge&#60<b>T extends</b> object, <b>U extends</b> object>(objA: <b>T</b>, objB: <b>U</b>) {
              return Object.assign(objA, objB); }</li>
            <li>type Length = { length: number; }; <br>
              function getLength&#60<b>T extends</b> Length>(str: <b>T</b>) { return str.length; }</li>
            <li>type Person = { name: string; age: number; }; <br>
              function extractValue&#60<b>T extends</b> object, <b>U extends</b> keyof T>(obj: <b>T</b>, key: <b>U</b>)
              { return obj[key]; }</li>
          </ul>
        </li>
        <li><b>Index Properties</b>
          <ul>
            <li>type Person = { <b>[key: string]</b>: string; }; <br>
              const user: Person = { gender: 'MAN', };</li>
          </ul>
        </li>
        <li><b>Function Overloads</b> <i>(differs behavior of a function depending on the type and number of
            argumentsand also can return different types)</i>
          <ul>
            <li>function concatenate(strs: string[ ]): string; <br>
              function concatenate(strs: string[ ], separator: string): string; <br>
              function concatenate(strs: any, separator?: any): any { <br>
              if (separator !== undefined) { <br>
              return strs.join(separator); <br>
              } else { <br>
              return strs.join(''); } }</li>
          </ul>
        </li>
      </ul>


      <a href="#types">
        <h3>Generics</h3>
      </a>
      <ul>
        <li><b>T</b>
          <ul>
            <li>function identity&#60<b>T</b>>(arg: <b>T</b>): <b>T</b> { return arg; }; <br>
              let output1 = identity("myString"); <br>
              let output2 = identity&#60number>(100);
            </li>
          </ul>
        </li>
        <li><b>T, U</b>
          <ul>
            <li>
              type Person = { name: string; }; <br>
              type AdditionFields = { age: number; }; <br>
              function merge&#60<b>T extends</b> object, <b>U extends</b>>(objA: <b>T</b>, objB: <b>U</b>)
              { return Object.assign(objA, objB); } <br>
              const merged = merge&#60Person, AdditionFields>({ name: 'Alisa' }, { age: 28 });
            </li>
            <li>
              class KeyValuePair&#60<b>K</b>, <b>V</b>> { <br>
              constructor(private key: <b>K</b>, private value: <b>V</b>) { } <br>
              getKey( ): K { return this.key; } <br>
              getValue( ): V { return this.value; } }
            </li>
          </ul>
        </li>
        <li><b>Partial&#60T></b> <i>(to make all properties optional)</i>
          <ul>
            <li>
              type User = { id: number; name: string; email: string; }; <br>
              function createUser(data: <b>Partial&#60</b>User<b>></b>): User { <br>
              const defaultUser: User = { id: Date.now( ), name: '', email: '', }; <br>
              return { ...defaultUser, ...data }; }
            </li>
          </ul>
        </li>
        <li><b>Readonly&#60T></b>, <b>ReadonlyArray&#60T></b> <i>(to make all properties read-only)</i>
          <ul>
            <li>
              type User = { id: number; name: string; email: string; }; <br>
              let aliceReadonly: <b>Readonly&#60</b>User<b>></b> = { <br>
              id: 1, name: 'Alice', email: 'alice@example.com', };
            </li>
            <li>const arr: <b>Readonly&#60</b>string[ ]<b>></b> = ['One', 'Two', 'Three']; </li>
          </ul>
        </li>
        <li><b>Pick&#60T, K></b> <i>(to create a new type based on selected properties)</i>
          <ul>
            <li>
              type User = { id: number; name: string; email: string;}; <br>
              type UserBasicInfo = <b>Pick&#60</b>User, 'name' | 'email'<b>></b>;
            </li>
          </ul>
        </li>
        <li><b>Omit&#60T, K></b> <i>(to create a new type based on excluded properties)</i>
          <ul>
            <li>
              type Person = { name: string; age: number; location: string; }; <br>
              type PersonWithoutLocation = <b>Omit&#60</b>Person, 'location'<b>></b>;
            </li>
          </ul>
        </li>
        <li><b>Record&#60K, T></b> <i>(to create types with predefined properties)</i>
          <ul>
            <li>
              type Weekdays = 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri' | 'Sat' | 'Sun'; <br>
              type DayTranslations = <b>Record&#60</b>Weekdays, string<b>></b>;
            </li>
            <li>
              enum UserRoles { admin = 'admin', manager = 'manager', } <br>
              type UserRolesStatuses = <b>Record&#60</b>UserRoles, boolean<b>></b>; <br>
              const userRoleStatuses: UserRolesStatuses = { <br>
              [UserRoles.admin]: true, <br>
              [UserRoles.manager]: false, };
            </li>
            <li>
              type InitialFormType = { name: string; email: string; password: string; }; <br>
              type Form = InitialFormType <b>&</b> { <br>
              errors: Partial<b>&#60Record</b>&#60keyof InitialFormType, [string]><b>></b>; };
            </li>
          </ul>
        </li>
        <li><b>ReturnType&#60T></b> <i>(to get the return type of the function)</i>
          <ul>
            <li>
              function greeting( ) { return 'Hello, world!'; } <br>
              type Greeting = <b>ReturnType&#60typeof</b> greeting<b>></b>; // 'string'
            </li>
            <li>
              function multiply(a: number, b: number) { return a * b; } <br>
              type MultiplyResult = <b>ReturnType&#60typeof</b> multiply<b>></b>; // 'number'
            </li>
          </ul>
        </li>
        <li><b>Parameters&#60T></b> <i>(to get a tuple of parameter types of the function)</i>
          <ul>
            <li>
              type MyFunctionType = (a: string, b: number, c: boolean) => void; <br>
              type MyParametersType = <b>Parameters&#60</b>MyFunctionType<b>></b>; // [string, number, boolean]
            </li>
          </ul>
        </li>
        <li><b>Promise&#60T></b>
          <ul>
            <li>const promise: Promise<b>&#60</b>string<b>></b> = new Promise<b>&#60</b>string<b>></b>((resolve) => {
              setInterval(( ) => { resolve('Done!'); }, 1000); });</li>
          </ul>
        </li>
        <li><b>Array&#60T></b>
          <ul>
            <li>let numbers: Array&#60number> = [1, 2, 3, 4, 5]</li>
          </ul>
        </li>
        <li><b>Map&#60K, V></b>, <b>Set&#60T></b></li>
        <li><b><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank"
              rel="noopener noreferrer">Utility Types</a></b></li>
      </ul>

    </section>

    <section class="oop">
      <a href="#goit">
        <h2 id="oop"> <span>(Lesson 3)</span></h2>
      </a>
      <h3>Classes</h3>
      <ul>
        <li><b>public</b> - <i>can be accessed anywhere</i> <br>
          <b>private</b> - <i>doesn’t allow access to the member even from subclasses</i> <br>
          <b>protected</b> - <i>is visible to subclasses of the class they’re declared in</i><br>
          <b>readonly</b> - <i>prevents assignments to the field outside of the constructor</i> <br>
          class House { <br>
          <b>private</b> city: string; <br>
          <b>private</b> tenants: string[ ] = [ ]; <br>
          constructor(name: string) { <b>this</b>.city = name; } <br>
          <b>public</b> showAddress(<b>this</b>: House) { console.log(`Address: ${<b>this</b>.city}`); } <br>
          <b>public</b> addTenant(tenant: string) { this.tenants.push(tenant); } <br>
          <b>public</b> showTenants( ) { console.log(this.tenants); } <br>
          }
        </li>
        <li><b>short syntax</b> <br>
          class House { <br>
          constructor(<b>private readonly</b> type: string, <b>private</b> city: string) { <br>
          this.city = city;
          }}
        </li>
        <li><b>extends</b>, <b>super( )</b> <br>
          class StoneHouse <b>extends</b> House { <br>
          private chargeOfTheHouse: string; <br>
          constructor(street: string, generalTenant: string) { <br>
          <b>super(</b>'stone', street<b>)</b>; <br>
          this.chargeOfTheHouse = generalTenant; <br>
          this.addTenant(generalTenant); } <br>
          public showTenants( ) { <br>
          console.log('General: ' + this.chargeOfTheHouse); <br>
          <b>super</b>.showTenants( ); } }
        </li>
        <li><b>getter</b>, <b>setter</b> <br>
          class Person { <br>
          private personInfo: PersonInformation = { }; <br>
          <b>set</b> firstName(value: string) { this.personInfo.firstName = value; } <br>
          <b>set</b> lastName(value: string) { this.personInfo.lastName = value; } <br>
          <b>get</b> info( ) { const { personInfo } = this; <br>
          return `${personInfo.lastName} ${personInfo.firstName}`; } }
        </li>
        <li><b>static</b> - <i>to write a sequence of statements with their own scope that can access private fields
            within the containing class</i><br>
          class UseStatic { <br>
          private <b>static</b> count = 0; <br>
          constructor( ) { UseStatic.count += 1; } <br>
          public <b>static</b> itStaticMethod( ) { console.log('Run static method'); } <br>
          public showCount( ) { console.log(UseStatic.count); } }
        </li>
        <li><b>abstract class</b> - <i> is one that hasn’t had an implementation provided</i><br>
          <b>abstract class</b> Plane { <br>
          protected pilotInCabin = false; <br>
          public sitInPlane( ) { this.pilotInCabin = true; } <br>
          <b>public abstract</b> startEngine( ): boolean; } <br>
          class Boeing extends Plane { <br>
          public startEngine( ) { return true; } }
        </li>
      </ul>

      <h3>Interfaces</h3>
      <ul>
        <li>
          <b>interface</b> IPerson { <b>readonly</b> name: string; age: number; greet(phrase: string): void; } <br>
          <b>interface</b> IPilot { flyMessage( ): void; }
        </li>
        <li>
          class Pilot <b>implements</b> IPerson, IPilot { <br>
          constructor(public name: string, public age: number) { <br>
          if (this.age < 28) { throw new Error('Pilot too young'); } } <br>
            greet(phrase: string): void { console.log(phrase + ' ' + this.name); } <br>
            flyMessage( ): void { console.log('Let's fly, have fun!'); } }
        </li>
        <li>
          interface IPilot <b>extends</b> IPerson { flyMessage( ): void; }
        </li>
        <li>
          <b>interface</b> AddFunc { (n1: number, n2: number): number; } <br>
          const add: AddFunc = (n1: number, n2: number) => { return n1 + n2; };
        </li>
        <li><b>implements</b> - to check that a class satisfies a particular interface;</li>
        <li><b>extend</b> - a derived class has all the properties and methods of its base class, and can also define
          additional members.
        </li>
      </ul>

      <h3>Patterns</h3>
      <ul>
        <li><b>Singleton</b> <br>
          class App { private static instance: App; <br>
          constructor( ) { if (!App.instance) { <br>
          App.instance = this; } <br>
          return App.instance; <br>
          } // ... }
        </li>
        <li><b>Factory</b> <br>
          interface PaymentProcessor { validate(data: any): boolean; pay(amount: number): void; } <br>

          class CreditCardProcessor implements PaymentProcessor { <br>
          validate(data: any): boolean { return true; } <br>
          pay(amount: number): void { console.log(`Paid ${amount} using Credit Card.`); } } <br>

          class PayPalProcessor implements PaymentProcessor { <br>
          validate(data: any): boolean { return true; } <br>

          pay(amount: number): void { console.log(`Paid ${amount} using PayPal.`); } } <br>

          class PaymentProcessorFactory { <br>
          static createProcessor(type: string): PaymentProcessor { <br>
          switch (type) { <br>
          case 'CreditCard': return new CreditCardProcessor( ); <br>
          case 'PayPal': return new PayPalProcessor( ); <br>
          default: throw new Error(`Payment method ${type} is not supported.`); <br>
          } } }
        </li>
        <li><b>Builder</b> <br>
          class Car { constructor( public model: string, public year: number, public color: string, ) {} } <br>

          class CarBuilder { private model: string; private year: number; private color: string; <br>

          setModel(model: string): CarBuilder { this.model = model; return this; } <br>
          setYear(year: number): CarBuilder { this.year = year; return this; } <br>
          setColor(color: string): CarBuilder { this.color = color; return this; } <br>
          build( ): Car { return new Car(this.model, this.year, this.color); } } <br>

          const builder = new CarBuilder( ); <br>

          const car = builder.setModel('Tesla Model S').setYear(2023).setColor('Red').build( );
        </li>
        <li><b>Adapter</b> <br>
          class OldService { public oldRequest( ): string { return 'Old Service Request'; } } <br>

          interface NewInterface { request( ): string; } <br>

          class Adapter implements NewInterface { <br>
          constructor(private oldService: OldService) {} <br>
          public request( ): string { <br>
          const result = this.oldService.oldRequest( ); <br>
          return `Adapter: (TRANSLATED) ${result}`; } } <br>

          class Client { <br>
          constructor(private newInterface: NewInterface) {} <br>
          public useService( ): void { <br>
          console.log(this.newInterface.request( )); } } <br>

          const oldService = new OldService( ); <br>
          const adapter = new Adapter(oldService); <br>
          const client = new Client(adapter); <br>

          client.useService( );
        </li>
        <li><b>Decorator</b> <br>
          interface Coffee { cost( ): number; description( ): string; } <br>

          class SimpleCoffee implements Coffee { cost( ) { return 10; } <br>
          description( ) { return 'Simple coffee'; } } <br>

          class CoffeeDecorator implements Coffee { <br>
          constructor(protected coffee: Coffee) {} <br>
          cost( ) { return this.coffee.cost( ); } <br>
          description( ) { return this.coffee.description( ); } } <br>

          class MilkDecorator extends CoffeeDecorator { <br>
          cost( ) { return this.coffee.cost( ) + 2; } <br>
          description( ) { return this.coffee.description( ) + ', milk'; } } <br>

          class SugarDecorator extends CoffeeDecorator { <br>
          cost( ) { return this.coffee.cost( ) + 1; } <br>
          description( ) { return this.coffee.description( ) + ', sugar'; } } <br>

          let coffee: Coffee = new SimpleCoffee( ); <br>
          coffee = new MilkDecorator(coffee); <br>
          coffee = new SugarDecorator(coffee); <br>

          console.log(`${coffee.description( )} - ${coffee.cost( )} dollars`);
        </li>
        <li><b>Facade</b> <br>
          type User = {id: number; name: string;email: string;}; <br>
          type Address = {userId: number;street: string; city: string; country: string; }; <br>
          type PaymentData = { userId: number; cardNumber: string; expiryDate: string; }; <br>
          class UserService { <br>
          getUser(id: number): User { console.log(`Fetching user data for userId: ${id}`); <br>
          return { id, name: 'John Doe', email: 'john.doe@example.com' }; } <br>

          updateUser(user: User): void { console.log(`Updating user: ${JSON.stringify(user)}`); } } <br>

          class AddressService { <br>
          getAddresses(userId: number): Address[] { console.log(`Fetching addresses for userId: ${userId}`); <br>
          return [{ userId, street: '123 Street', city: 'City', country: 'Country' }]; } <br>

          updateAddress(userId: number, address: Address): void <br>
          { console.log(`Updating address for userId: ${userId}`); } } <br>

          class PaymentService { <br>
          getPaymentData(userId: number): PaymentData { console.log(`Fetching payment data for userId: ${userId}`); <br>
          return { userId, cardNumber: '1234 5678 9012 3456', expiryDate: '01/25' }; } <br>

          updatePaymentData(userId: number, paymentData: PaymentData): void { <br>
          console.log(`Updating payment data for userId: ${userId}`); } } <br>

          class UserProfileFacade { <br>
          constructor( <br>
          private userService: UserService, <br>
          private addressService: AddressService, <br>
          private paymentService: PaymentService, ) {} <br>

          getUserProfile(userId: number): User { <br>
          const user = this.userService.getUser(userId); <br>
          user['addresses'] = this.addressService.getAddresses(userId); <br>
          user['paymentData'] = this.paymentService.getPaymentData(userId); <br>
          return user; } <br>

          updateUserProfile( userId: number, userData: User, address: Address, paymentData: PaymentData, ): void { <br>
          this.userService.updateUser(userData); <br>
          this.addressService.updateAddress(userId, address); <br>
          this.paymentService.updatePaymentData(userId, paymentData); } }
        </li>
        <li><b>State</b> <br>
          interface State { proceedToNext(order: Order): void; toString( ): string; } <br>
          class Order { private state: State; constructor( ) { this.state = new PendingState( ); } <br>
          public proceedToNext( ) { this.state.proceedToNext(this); } <br>
          public setState(state: State) { this.state = state; } <br>
          public toString( ): string { return this.state.toString( ); } } <br>
          class PendingState implements State { <br>
          public proceedToNext(order: Order): void { <br>
          console.log('Proceeding from Pending to Shipped...'); <br>
          order.setState(new ShippedState( )); } <br>

          public toString( ): string { return 'Pending'; } } <br>

          class ShippedState implements State { <br>
          public proceedToNext(order: Order): void { <br>
          console.log('Proceeding from Shipped to Delivered...'); <br>
          order.setState(new DeliveredState( )); } <br>

          public toString( ): string { return 'Shipped'; } } <br>

          class DeliveredState implements State { <br>
          public proceedToNext(order: Order): void { <br>
          console.log('Already delivered. Thank you!'); } <br>

          public toString( ): string { return 'Delivered'; } } <br>

          let order = new Order( ); <br>
          order.proceedToNext( ); <br>
          order.proceedToNext( ); <br>
          order.proceedToNext( );
        </li>
      </ul>
    </section>

    <section class="react">
      <a href="#goit">
        <h2 id="react"> <span>(Lesson 4)</span></h2>
      </a>
      <h3></h3>



    </section>

    <section class="decorators">
      <a href="#goit">
        <h2 id="decorators"> <span>(Lesson 5)</span></h2>
      </a>
    </section>

    <section class="nodejs">
      <a href="#goit">
        <h2 id="nodejs"> <span>(Lesson 6)</span></h2>
      </a>
    </section>
    <footer></footer>
</body>

</html>